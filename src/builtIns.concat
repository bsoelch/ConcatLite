import "common.concat"
import map
using std.literals.

enum( ADD_I32 SUB_I32 MUL_I32 LT_I32 EQ_I32 DUP SWAP OVER DROP PRINT ) =:: export: BuiltIn

proc( string Identifier hashMap ptr.mut : idNames string : name Type : t -> ) =>: newBuiltInType
  idNames name
    t Value .Type Type .Type TypedValue new
    IdModifier.BUILTIN
  IdData new Identifier .Variable map.put ..drop
end
proc( Program ptr.mut : program -> ) =>: export: initBuiltIns
  program .identifiers "bool":s Type .Bool newBuiltInType
  program .identifiers "i8":s  Type .I8  newBuiltInType
  program .identifiers "i16":s Type .I16 newBuiltInType
  program .identifiers "i32":s Type .I32 newBuiltInType
  program .identifiers "i64":s Type .I64 newBuiltInType
  program .identifiers "f16":s Type .F16 newBuiltInType
  program .identifiers "f32":s Type .F32 newBuiltInType
  program .identifiers "f64":s Type .F64 newBuiltInType
  program .identifiers "type":s Type .Type newBuiltInType
  program [] .memory
    { Type .I32 Type .I32 } slice.wrap
      BuiltIn .ADD_I32 ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: ADD_I32_ID
    { Type .I32 Type .I32 } slice.wrap
      BuiltIn .SUB_I32 ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: SUB_I32_ID
    { Type .I32 Type .I32 } slice.wrap
      BuiltIn .MUL_I32 ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: MUL_I32_ID
    { Type .I32 Type .I32 } slice.wrap
      BuiltIn .LT_I32 ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: LT_I32_ID
    { Type .I32 Type .I32 } slice.wrap
      BuiltIn .EQ_I32 ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: EQ_I32_ID
    { Type .None } slice.wrap
      BuiltIn .PRINT ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: PRINT_ID
    { Type .None } slice.wrap
      BuiltIn .DUP ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: DUP_ID
    { Type .None Type .None } slice.wrap
      BuiltIn .SWAP ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: SWAP_ID
    { Type .None Type .None } slice.wrap
      BuiltIn .OVER ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: OVER_ID
    { Type .None } slice.wrap
      BuiltIn .DROP ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: DROP_ID
  program .memory=
  program .identifiers "+":s ADD_I32_ID Identifier .Procedure map.put ..drop
  program .identifiers "-":s SUB_I32_ID Identifier .Procedure map.put ..drop
  program .identifiers "*":s MUL_I32_ID Identifier .Procedure map.put ..drop
  program .identifiers "<":s LT_I32_ID Identifier .Procedure map.put ..drop
  program .identifiers "==":s EQ_I32_ID Identifier .Procedure map.put ..drop
  program .identifiers "print":s PRINT_ID Identifier .Procedure map.put ..drop
  program .identifiers "$":s DUP_ID Identifier .Procedure map.put ..drop
  program .identifiers ">$":s SWAP_ID Identifier .Procedure map.put ..drop
  program .identifiers "$1":s OVER_ID Identifier .Procedure map.put ..drop
  program .identifiers "..drop":s DROP_ID Identifier .Procedure map.put ..drop
end
proc( BuiltIn : builtIn Program ptr.mut : program -> )  =>: export: evaluateBuiltIn
  builtIn switch
    ## TODO? extract common code
    ADD_I32 case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: b
        list.pop =:: a
        a asI32 b asI32 + i64 cast.u Value .Int Type .I32 TypedValue new list.push
      program .stack=
      break
    SUB_I32 case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: b
        list.pop =:: a
        a asI32 b asI32 - i64 cast.u Value .Int Type .I32 TypedValue new list.push
      program .stack=
      break
    MUL_I32 case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: b
        list.pop =:: a
        a asI32 b asI32 * i64 cast.u Value .Int Type .I32 TypedValue new list.push
      program .stack=
      break
    LT_I32 case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: b
        list.pop =:: a
        a asI32 b asI32 < Value .Bool Type .Bool TypedValue new list.push
      program .stack=
      break
    EQ_I32 case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: b
        list.pop =:: a
        a asI32 b asI32 == Value .Bool Type .Bool TypedValue new list.push
      program .stack=
      break
    DUP case
      1:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        $ list.peek .data list.appendP
      program .stack=
      break
    SWAP case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: a
        list.pop =:: b
        a list.push
        b list.push
      program .stack=
      break
    OVER case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        $ $ .length 2:iSize - [] list.push
      program .stack=
      break
    DROP case
      1:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop ..drop
      program .stack=
      break
    PRINT case
      1:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop .value printValue '\n' io.print
      program .stack=
      break
  end
end
