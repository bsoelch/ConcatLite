import "common.concat"
import map
using std.literals.

enum( ADD_I32 SUB_I32 MUL_I32 LT_I32 EQ_I32 PRINT ) =:: export: BuiltIn

proc( IdName Identifier hashMap ptr.mut : idNames string : name Type : t -> ) =>: newBuiltInType
  idNames name FileId.GLOBAL IdName new
    t Value .Type Type .Type TypedValue new
    IdModifier.BUILTIN
  Identifier new map.put ..drop
end
proc( IdName Identifier hashMap ptr.mut : idNames string : name Procedure ptr : proc -> ) =>: newBuiltInProc
  idNames name FileId.GLOBAL IdName new
    proc Value .Procedure proc [] .procType Type .Procedure TypedValue new
    IdModifier.BUILTIN
  Identifier new map.put ..drop
end
proc( Program ptr.mut : program -> ) =>: export: initBuiltIns
  program .identifiers "bool":s Type .Bool newBuiltInType
  program .identifiers "i8":s  Type .I8  newBuiltInType
  program .identifiers "i16":s Type .I16 newBuiltInType
  program .identifiers "i32":s Type .I32 newBuiltInType
  program .identifiers "i64":s Type .I64 newBuiltInType
  program .identifiers "f16":s Type .F16 newBuiltInType
  program .identifiers "f32":s Type .F32 newBuiltInType
  program .identifiers "f64":s Type .F64 newBuiltInType
  program .identifiers "type":s Type .Type newBuiltInType
  program [] .memory
    Type .None mixedArena.copyValue =:: None1
    { Type .I32 Type .I32 } mixedArena.copyPtrs =:: i32i32
    { Type .Bool Type .Bool } mixedArena.copyPtrs =:: boolbool
    { Type .Bool Type .I32 } mixedArena.copyPtrs =:: typei32
    ## ProcedureType
      None1 slice.wrap CompositeType new
      Type slice.empty CompositeType new
    ProcedureType new mixedArena.copyValue =:: None_
    ## ProcedureType
      typei32 slice.wrap CompositeType new
      typei32 1 slice.create CompositeType new
    ProcedureType new mixedArena.copyValue =:: typei32_type
    ## ProcedureType
      i32i32 slice.wrap CompositeType new
      i32i32 1 slice.create CompositeType new
    ProcedureType new mixedArena.copyValue =:: i32i32_i32
    ## ProcedureType
      i32i32 slice.wrap CompositeType new
      boolbool 1 slice.create CompositeType new
    ProcedureType new mixedArena.copyValue =:: i32i32_bool
    i32i32_i32
      BuiltIn .ADD_I32 ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: ADD_I32_ID
    i32i32_i32
      BuiltIn .SUB_I32 ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: SUB_I32_ID
    i32i32_i32
      BuiltIn .MUL_I32 ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: MUL_I32_ID
    i32i32_bool
      BuiltIn .LT_I32 ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: LT_I32_ID
    i32i32_bool
      BuiltIn .EQ_I32 ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: EQ_I32_ID
    None_
      BuiltIn .PRINT ProcImplementation .builtIn
    Procedure new mixedArena.copyValue =:: PRINT_ID
  program .memory=
  program .identifiers "+":s ADD_I32_ID newBuiltInProc
  program .identifiers "-":s SUB_I32_ID newBuiltInProc
  program .identifiers "*":s MUL_I32_ID newBuiltInProc
  program .identifiers "<":s LT_I32_ID newBuiltInProc
  program .identifiers "==":s EQ_I32_ID newBuiltInProc
  program .identifiers "print":s PRINT_ID newBuiltInProc
end
proc( BuiltIn : builtIn Program ptr.mut : program -> )  =>: export: evaluateBuiltIn
  builtIn switch
    ## TODO? extract common code
    ADD_I32 case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: b
        list.pop =:: a
        a asI32 b asI32 + i64 cast.u Value .Int Type .I32 TypedValue new list.push
      program .stack=
      break
    SUB_I32 case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: b
        list.pop =:: a
        a asI32 b asI32 - i64 cast.u Value .Int Type .I32 TypedValue new list.push
      program .stack=
      break
    MUL_I32 case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: b
        list.pop =:: a
        a asI32 b asI32 * i64 cast.u Value .Int Type .I32 TypedValue new list.push
      program .stack=
      break
    LT_I32 case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: b
        list.pop =:: a
        a asI32 b asI32 < Value .Bool Type .Bool TypedValue new list.push
      program .stack=
      break
    EQ_I32 case
      2:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop =:: b
        list.pop =:: a
        a asI32 b asI32 == Value .Bool Type .Bool TypedValue new list.push
      program .stack=
      break
    PRINT case
      1:iSize program checkStack if
        "stack underflow" ..panic
      end
      program [] .stack
        list.pop .value printValue '\n' io.print
      program .stack=
      break
  end
end
