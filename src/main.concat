import io
import stringIO
import arenaAlloc
import numbers
import chars
import map
using std.literals.

import "common.concat"
import "builtIns.concat"

proc( stringBuilder -> stringBuilder ) =>: readLine
  while
    io.getChar ..drop =:: mut: c
    c '\n' !=
  do
    c sb.appendC
  end
end

struct(
  MixedArenaAllocator : memory
  Procedure list : procedures
  string Identifier hashMap : identifiers
  TypedValue list : stack
  ## parser state
  ## TODO remember open blocks
  Token list : tokens
  i32 : parseOffset
  bool : running
) =:: export: Program

proc( MixedArenaAllocator ptr.mut : alloc string : str -> string ) =>: copyString
  alloc [] str string.chars mixedArena.copySlice slice.freeze string.fromChars >$ alloc =[]
end

proc( string : mut: next Program ptr.mut : program -> i32 Token ) =>: nextToken
  0 =:: mut: i0
  ## skip leading spaces
  while next .length 0:iSize != and next 0 string.charAt char.isSpace do i0 1 + i0= end
  next i0 string.tail next=
  next .length 0:iSize == if
    i0 Token .EOF return
  end
  0 =:: mut: i
  while i iSize cast.u next .length u< and next i string.charAt char.isSpace ! do
    i 1 + i=
  end
  i0 i + 1 +
  next i string.head =:: word
  word .length 0:iSize != and word 0 string.charAt char.isDigit if
    word 0 number.tryParseInt switch
      NONE case Token .Integer return
      UNSIGNED case ## TODO warning
        Token .Integer return
      SIGN case "error handling" ..panic
      OVERFLOW case "error handling" ..panic
      default ..drop break
    end
    word 0 number.tryParseFloat switch
      NONE INT case Token .Float return
      default "error handling" ..panic
    end
  end
  word "if":s string.eq if
    "unimplemented" ..panic
  else word "_if":s string.eq _if
    "unimplemented" ..panic
  else word "else":s string.eq _if
    "unimplemented" ..panic
  else word "while":s string.eq _if
    "unimplemented" ..panic
  else word "do":s string.eq _if
    "unimplemented" ..panic
  else word "finally":s string.eq _if
    "unimplemented" ..panic
  else word "break":s string.eq _if
    "unimplemented" ..panic
  else word "continue":s string.eq _if
    "unimplemented" ..panic
  else word "end":s string.eq _if
    "unimplemented" ..panic
  end
  ## TODO? resolve identifiers outside procedures at parse time
  program .memory word copyString Token .Identifier
end
## parse a single line returns true if line needs to be continued
proc( string : line Program ptr.mut : program -> bool ) =>: parseLine
  line "exit":s string.eq if
    false program .running=
    false return
  end
  while
    line program [] .parseOffset string.tail program nextToken =:: token =:: consumed
    program [] .parseOffset consumed + program .parseOffset=
    token .EOF ?? !
  do ## TODO make sure to copy strings
    program [] .tokens
      token list.append
    program .tokens=
  end
  program [] .parseOffset iSize cast.u line .length u< if
    true return
  end
  ## TODO ensure there are no open blocks
  program [] .tokens for printToken end
  ## TODO? type-check before interpreting
  program [] .tokens list.asSlice program evaluateBlock
  false return
end

proc( ProcId : procId Program ptr.mut : program -> ) =>: evaluateCall
  program [] .procedures procId iSize cast.u [] =:: procData
  ## TODO? check arguments
  procData .implementation switch
    code case
      procData .implementation .code program evaluateBlock
      break
    builtIn case
      procData .implementation .builtIn program evaluateBuiltIn
      break
  end
end
proc( Token slice : tokens Program ptr.mut : program -> ) =>: evaluateBlock
  0:i32 =:: mut: ip
  while ip iSize cast.u tokens .length u< do
    tokens ip [] =:: token
    token switch
      Identifier case
        program .identifiers token .Identifier map.get =:: idData?
        idData? optional.isEmpty if
          "Unknown identifier: \"":s io.print
          token .Identifier io.print
          "\"":s io.println
          return
        end
        idData? .data =:: idData
        idData switch
          Variable case
            program [] .stack
              idData .Variable list.append
            program .stack=
            break
          Procedure case
            idData .Procedure program evaluateCall
            break
        end
        break
      Integer case
        program [] .stack
          token .Integer Value .Int Type .NONE TypedValue new list.append
        program .stack=
        break
      Float case "Floats are not supported" ..panic
      EOF case return
    end
  finally ip 1 + ip= end
end

5:iSize =:: MAX_ELTS
proc( -> ) =>: main
  ## Program
    4096 mixedArena.create
    128 Procedure list.create
    string.hash@ string.eq@ 1024 Identifier map.create
    128 TypedValue list.create
    128 Token list.create
    0:i32
    true
  Program new =:: mut: program
  program@ initBuiltIns
  256 sb.create =:: mut: lineBuffer
  while program .running do
    " >> ":s io.print
    lineBuffer readLine lineBuffer=
    0 program@ .parseOffset=
    while
      lineBuffer sb.asStr program@ parseLine
    do
      "... ":s io.print
      lineBuffer '\n' sb.appendC readLine lineBuffer=
    end
    lineBuffer sb.clear lineBuffer=
    program .tokens list.clear program@ .tokens=
    program .stack .length MAX_ELTS u> if
      " ...":s io.print
    end
    program .stack list.asSlice
      $ .length MAX_ELTS u> if
        $ .length MAX_ELTS - slice.tail
      end
    for =:: elt
      ' ' io.print elt printTypedValue
    end
    '\n' io.print
  end
  lineBuffer sb.free ..drop
end
