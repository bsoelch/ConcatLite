import io
import stringIO
import numbers
import chars
import sys
using std.literals.

import "common.concat"
import "builtIns.concat"

proc( stringBuilder -> stringBuilder ) =>: readLine
  while
    io.getChar ..drop =:: mut: c
    c '\n' !=
  do
    c sb.appendC
  end
end

proc( string : word Program ptr.mut : program -> string ) =>: copyName
  program [] .memory
    word string.chars mixedArena.copySlice slice.freeze string.fromChars >$
  program .memory=
end

proc( string : mut: next -> i32 string string ) =>: nextWord
  0 =:: mut: i0
  0 =:: mut: i
  while
    ## skip leading spaces
    while i iSize cast.u next .length u< and next i string.charAt char.isSpace do i 1 + i= end
    next i string.tail next=
    i0 i + i0=
    0 i=
    next "##":s string.startsWith if ## line comment
      i 2 + i=
      while i iSize cast.u next .length u< and next i string.charAt '\n' != do i 1 + i= end
      continue
    end
    next "#+":s string.startsWith if ## block comment
      i 3 + i=
      1 =:: mut: level
      while i iSize cast.u next .length u< and level 0 > do
        next i 1 - string.charAt '+' == and next i string.charAt '#' == if
          i 1 + i=
          level 1 - level=
        else next i 1 - string.charAt '#' == and next i string.charAt '+' == _if
          i 1 + i=
          level 1 + level=
        end
        i 1 + i=
      end
      level 0 > if i0 next string.empty return end
      continue
    end
    false
  end
  next .length 0:iSize == if
    i0 next next return
  end
  i 0 == "index gets reset in loop" assert
  ## strings
  ## TODO? change return type to distinguish different types of "words" ( identifier,  string, literal-modifier)
  next 0 string.charAt =:: c0
  c0 '"' == or c0 '\'' == if
    1 i=
    while i iSize cast.u next .length u< and next i string.charAt c0 != do
      i
        next i string.charAt '\\' == if 1 + end
        1 +
      i=
    end
    i iSize cast.u next .length u>= if i0 next string.empty return end
  else c0 '`' == _if
    1 i=
    while i iSize cast.u next .length u< do
      next i string.charAt c0 == if
        i 1 + iSize cast.u next .length u< and next i 1 + string.charAt c0 == if
          i 1 + i= ## escaped `
        else
          break
        end
      end
      i 1 + i=
    end
    i iSize cast.u next .length u>= if i0 next string.empty return end
  end
  while i iSize cast.u next .length u< and next i string.charAt char.isSpace ! do
    i 1 + i=
  end
  i0 next i iSize cast.u string.cutIndex
end
proc( string : mut: expr -> i32 IdModifier string ) =>: parseDeclaration
  IdModifier.NONE =:: mut: modifiers
  string.empty =:: mut: name
  0 =:: mut: i
  while
    expr nextWord name= expr= i + i=
    name .length 0:iSize == if 0 modifiers name return end
    i name .length i32 cast.u + i=
    name $ .length 1:iSize - string.charAt ':' ==
  do
    name $ .length 1:iSize - string.head =:: modif
    modif "mut":s string.eq if
      modifiers IdModifier.MUTABLE | modifiers=
    end
    modif "export":s string.eq if
      modifiers IdModifier.EXPORT | modifiers=
    end
    modif "global":s string.eq if
      modifiers IdModifier.GLOBAL | modifiers=
    end
  end
  i modifiers name
end
proc( CompositeBlockType : compType Program ptr.mut : program -> ) =>: startCompositeBlock
  program [] .openBlocks
    ## CompositeBlockInfo
      program [] .tokens .length i32 cast.u ## blockStart
      -1 ## toIndex
      compType
    CompositeBlockInfo new BlockInfo .compositeBlock list.push
  program .openBlocks=
end
proc( string : mut: chars bool : rawString Program ptr.mut : program -> StringLiteral ) =>: parseStringLiteral
  chars 0:iSize string.charAt chars $ .length 1:iSize - string.charAt == "literal starts and ends with same char" assert
  chars 1:iSize $1 .length 2:iSize - string.getSlice chars=
  program [] .memory ## TODO? reduce wasted space
    chars .length i32 cast.u char8 mixedArena.allocSlice =:: stringData
  program .memory=
  stringData .data stringData .length sb.fromBuffer
    rawString if
      0:iSize while $ chars .length u< do =:: mut: i
        chars i string.charAt =:: c
        c sb.appendC
        c '`' == if ## ignore character after '`' within string
          i 1:iSize + i=
        end
      finally i 1:iSize + end ..drop
    else
      0:iSize while $ chars .length u< do =:: mut: i
        chars i string.charAt =:: c
        c '\\' != if
          c sb.appendC
          continue
        end
        i 1:iSize + i=
        chars i string.charAt =:: c1
        c1 switch
          'x' 'u' 'U' case "unimplemented" ..panic
          'n' case '\n' sb.appendC break
          't' case '\t' sb.appendC break
          'b' case '\b' sb.appendC break
          'r' case '\r' sb.appendC break
          'f' case '\f' sb.appendC break
          'v' case '\v' sb.appendC break
          default c1 sb.appendC break
        end
      finally
        i 1:iSize +
      end ..drop
    end
  =:: stringValue
  stringValue .data stringValue .length i32 cast.u StringLiteral new
end
proc( string : mut: next Program ptr.mut : program -> i32 Token ) =>: nextToken
  next nextWord =:: word next= =:: i0
  word .length 0:iSize == if
    i0 Token .EOF return
  end
  i0 word .length i32 cast.u +
  word 0 string.charAt =:: c0
  c0 '"' == or c0 '`' == if
    word c0 '`' == program parseStringLiteral =:: literal
    literal Value .String
      Type .Char8 literal .length i64 cast.u ArraySize .Fixed program newArrayType Type .Pointer
    TypedValue new Token .Constant return
  else c0 '\'' == _if
    word false program parseStringLiteral =:: literal
    literal .length 1 == if
      literal asString 0 string.charAt i64 cast.u Value .Int
        Type .Char8
      TypedValue new Token .Constant return
    end
    literal Value .String
      Type .Char8 literal .length i64 cast.u ArraySize .Fixed program newArrayType Type .Array
    TypedValue new Token .Constant return
  end
  c0 char.isDigit or
      word .length 2:iSize u>= and c0 '-' == c0 '+' == | and word 1 string.charAt char.isDigit if
    word 0 number.tryParseInt switch
      NONE case Value .Int Type .None TypedValue new Token .Constant return
      UNSIGNED case ## TODO warning
        Value .Int Type .None TypedValue new Token .Constant return
      SIGN case "error handling" ..panic
      OVERFLOW case "error handling" ..panic
      default ..drop break
    end
    word 0 number.tryParseFloat switch
      NONE INT case
        Value .Float Type .None TypedValue new Token .Constant return
      default "error handling" ..panic
    end
  end
  word ":":s string.eq if
    next parseDeclaration =:: name =:: idFlags +
      name .length 0:iSize == if ..drop i0 Token .EOF return end
    name program copyName idFlags InitType .DECLARE InitInfo new Token .Initialize return
  else word "=:":s string.eq _if
    next parseDeclaration =:: name =:: idFlags +
      name .length 0:iSize == if ..drop i0 Token .EOF return end
    name program copyName idFlags InitType .TYPED InitInfo new Token .Initialize return
  else word "=::":s string.eq _if
    next parseDeclaration =:: name =:: idFlags +
      name .length 0:iSize == if ..drop i0 Token .EOF return end
    name program copyName idFlags InitType .AUTO InitInfo new Token .Initialize return
  else word "$":s string.eq _if
    0 StackOp .Copy Token .StackOp return
  else word "$1":s string.eq _if
    1 StackOp .Copy Token .StackOp return
  else word ">$":s string.eq _if
    1 StackOp .Rotate Token .StackOp return
  else word "..drop":s string.eq _if
    1 StackOp .Drop Token .StackOp return
  else word .length 1:iSize u> and c0 '.' == _if
    word $ .length 1:iSize - string.charAt '=' == =:: setValue
    word 1 string.tail
      setValue if $ .length 1:iSize - string.head end
      $ .length 0:iSize == if
        "error handling" ..panic
      end
    =:: eltName
    eltName 0 string.charAt char.isDigit ! if
      eltName program copyName setValue if Token .SetNamedElement else Token .GetNamedElement end return
    end
    eltName 10 number.tryParseUInt switch
      NONE UNSIGNED case break
      default "error handling" ..panic
    end =:: eltId
    eltId setValue if Token .SetElement else Token .GetElement end return
  else word "new":s string.eq _if
    Token .New return
  else word "array":s string.eq _if
    ArrayKind .ARRAY Token .NewArrayType return
  else word "ptr":s string.eq _if
    ArrayKind .POINTER Token .NewArrayType return
  else word "ptr.mut":s string.eq _if
    ArrayKind .MUTABLE_POINTER Token .NewArrayType return
  else word "[]":s string.eq _if
    ArrayOperator .GET Token .ArrayOperator return
  else word "=[]":s string.eq _if
    ArrayOperator .SET Token .ArrayOperator return
  else word "@[]":s string.eq _if
    ArrayOperator .AT Token .ArrayOperator return
  else word "import":s string.eq _if
    next nextWord =:: name next= + name .length i32 cast.u +
    name 0 string.charAt '"' == if
      name 1:iSize $1 .length 2:iSize - string.getSlice program copyName Token .ImportLocal return
    else
      name program copyName Token .ImportLib return
    end
  else word "if":s string.eq _if
    program [] .openBlocks
      ## IfBlockInfo
        program [] .tokens .length i32 cast.u ## ifIndex
        -1 ## elseIndex
        false ## autoClose
      IfBlockInfo new BlockInfo .ifBlock list.push
    program .openBlocks=
    -1 BlockType .IF CodeBlock new Token .Block return
  else word "_if":s string.eq _if
    program [] .openBlocks
      ## IfBlockInfo
        program [] .tokens .length i32 cast.u ## ifIndex
        -1 ## elseIndex
        true ## autoClose
      IfBlockInfo new BlockInfo .ifBlock list.push
    program .openBlocks=
    -1 BlockType .IF CodeBlock new Token .Block return
  else word "else":s string.eq _if
    program [] .openBlocks list.peek =:: ifBlock?
    ifBlock? .data .ifBlock =:: ifBlock
    program [] .tokens .length i32 cast.u ifBlock .elseIndex=
    ifBlock [] .ifIndex =:: ifIndex
    program [] .tokens .length i32 cast.u ifIndex -
      program [] .tokens ifIndex @[]
    .Block .target=
    -1 BlockType .ELSE CodeBlock new Token .Block return
  else word "while":s string.eq _if
    program [] .openBlocks
      ## WhileBlockInfo
        program [] .tokens .length i32 cast.u ## whileIndex
        -1 ## doIndex
      WhileBlockInfo new BlockInfo .whileBlock list.push
    program .openBlocks=
    0 BlockType .WHILE CodeBlock new Token .Block return
  else word "do":s string.eq _if
    program [] .openBlocks list.peek =:: whileBlock?
    whileBlock? .data .whileBlock =:: whileBlock
    program [] .tokens .length i32 cast.u whileBlock .doIndex=
    -1 BlockType .DO CodeBlock new Token .Block return
  else word "finally":s string.eq _if
    "unimplemented" ..panic
  else word "break":s string.eq _if
    "unimplemented" ..panic
  else word "continue":s string.eq _if
    "unimplemented" ..panic
  else word "=>":s string.eq or word "=>:":s string.eq _if
    word .length 3:iSize == if
      next parseDeclaration =:: name =:: idFlags +
        name .length 0:iSize == if ..drop i0 Token .EOF return end
      name idFlags
    else
      string.empty IdModifier.NONE
    end =:: idFlags =:: name
    program [] .openBlocks
      ## ProcedureBlockInfo
        name ## procName
        program [] .tokens .length i32 cast.u ## blockStart
        idFlags ## idModifiers
      ProcedureBlockInfo new BlockInfo .procedureBlock list.push
    program .openBlocks=
    -1 BlockType .PROCEDURE CodeBlock new Token .Block return
  else word "end":s string.eq _if
    program [] .openBlocks .length 0:iSize == if
      "error handling" ..panic
    end
    program [] .openBlocks
      list.pop =:: closed
    program .openBlocks=
    closed switch
      ifBlock case
        closed .ifBlock .elseIndex =:: elseIndex
        elseIndex -1 == if ## no (explicit) else
          closed .ifBlock .ifIndex =:: ifIndex
          program [] .tokens .length i32 cast.u ifIndex -
            program [] .tokens ifIndex @[]
          .Block .target=
          program [] .tokens
            1 BlockType .ELSE CodeBlock new Token .Block list.append
          program .tokens=
        else
          program [] .tokens .length i32 cast.u elseIndex -
            program [] .tokens elseIndex @[]
          .Block .target=
        end
        0 BlockType .IF CodeBlock new Token .EndBlock return
      whileBlock case
        closed .whileBlock .whileIndex =:: whileIndex
        closed .whileBlock .doIndex =:: doIndex
        doIndex -1 == if ## no (explicit) do
          program [] .tokens
            1 BlockType .DO CodeBlock new Token .Block list.append
          program .tokens=
        else
          program [] .tokens .length i32 cast.u doIndex -
            program [] .tokens doIndex @[]
          .Block .target=
        end
        whileIndex program [] .tokens .length i32 cast.u -
          BlockType .WHILE
        CodeBlock new Token .EndBlock return
      procedureBlock case
        closed .procedureBlock .blockStart =:: blockStart
        program [] .tokens .length i32 cast.u blockStart -
          program [] .tokens blockStart @[]
        .Block .target=
        0 BlockType .PROCEDURE CodeBlock new Token .EndBlock =:: blockEnd
        closed .procedureBlock .procName .length 0:iSize == if
          blockEnd return
        end
        program [] .tokens blockEnd list.append program .tokens=
        closed .procedureBlock .procName program copyName
          closed .procedureBlock .idModifiers
        InitType .AUTO InitInfo new Token .Initialize return
      namespace case
        closed .namespace Token .EndNamespace return
      compositeBlock case "error handling" ..panic
    end
  else word "(":s string.eq _if
    CompositeBlockType .NONE program startCompositeBlock
    -1 BlockType .TUPLE_TYPE CodeBlock new Token .Block return
  else word "struct(":s string.eq _if
    CompositeBlockType .TUPLE program startCompositeBlock
    -1 BlockType .TUPLE_TYPE CodeBlock new Token .Block return
  else word "proc(":s string.eq _if
    CompositeBlockType .PROC program startCompositeBlock
    -1 BlockType .PROC_TYPE CodeBlock new Token .Block return
  else word "union(":s string.eq _if
    CompositeBlockType .UNION program startCompositeBlock
    -1 BlockType .UNION_TYPE CodeBlock new Token .Block return
  else word "enum(":s string.eq _if
    "unimplemented" ..panic ## TODO? directly parse names to enum
  else word "->":s string.eq _if
    program [] .openBlocks list.peek =:: procBlock?
    procBlock? .data .compositeBlock =:: procBlock
    procBlock .compType [] .NONE ?? if
      BlockType .PROC_TYPE program [] .tokens procBlock [] .blockStart @[] .Block .blockType=
      CompositeBlockType .PROC procBlock .compType=
    else procBlock .compType [] .PROC ?? ! or procBlock [] .toIndex -1 != _if
      "error handling" ..panic
    end
    program [] .tokens .length i32 cast.u procBlock .toIndex=
    0 BlockType .TO_TYPE CodeBlock new Token .Block return
  else word "{":s string.eq _if
    CompositeBlockType .INITIALIZER program startCompositeBlock
    -1 BlockType .INITIALIZER CodeBlock new Token .Block return
  else word ")":s string.eq or word "}":s string.eq _if
    program [] .openBlocks .length 0:iSize == if
      "error handling" ..panic
    end
    word "}":s string.eq =:: isInitializer
    program [] .openBlocks
      list.pop =:: closed
    program .openBlocks=
    closed .compositeBlock ?? ! or
        closed .compositeBlock .compType .INITIALIZER ?? isInitializer != if
      "error handling" ..panic
    end
    closed .compositeBlock .blockStart =:: startIndex
    program [] .tokens .length i32 cast.u startIndex -
      program [] .tokens startIndex @[]
    .Block .target=
    closed .compositeBlock .compType switch
      NONE TUPLE case
       0 BlockType .TUPLE_TYPE CodeBlock new Token .EndBlock return
      UNION case
       0 BlockType .UNION_TYPE CodeBlock new Token .EndBlock return
      PROC case
        closed .compositeBlock .toIndex =:: toIndex
        program [] .tokens .length i32 cast.u toIndex -
          program [] .tokens toIndex @[]
        .Block .target=
       0 BlockType .PROC_TYPE CodeBlock new Token .EndBlock return
      INITIALIZER case
       0 BlockType .INITIALIZER CodeBlock new Token .EndBlock return
    end
    ..unreachable
  else word "namespace:":s string.eq _if
    next parseDeclaration =:: mut: name =:: idFlags +
    name .length 0:iSize == if ..drop i0 Token .EOF return end
    name program copyName name=
    program [] .openBlocks
      name BlockInfo .namespace list.append
    program .openBlocks=
    name Token .BeginNamespace return
  end
  word .length 2:iSize u>= and word $ .length 1:iSize - string.charAt '=' == and
      word .length 2:iSize u> or "<>=!":s word 0 string.charAt string.contains ! if
    word $ .length 1:iSize - string.head program copyName Token .SetValue return
  end
  word program copyName Token .Identifier
end
## parse a single line returns true if line needs to be continued
proc( string : line Program ptr.mut : program -> bool ) =>: parseLine
  while
    line program [] .parseOffset string.tail program nextToken =:: token =:: consumed
    program [] .parseOffset consumed + program .parseOffset=
    token .EOF ?? !
  do
    program [] .tokens
      token list.append
    program .tokens=
  end
  program [] .parseOffset iSize cast.u line .length u< or
      program [] .openBlocks .length 0:iSize != if
    true return
  end
  0 program .parseOffset=
  false return
end

proc( Procedure ptr : procData Program ptr.mut : program -> ) =>: evaluateCall
  procData [] .procType .inTypes .elements [] .length program checkStack if
    "stack underflow" ..panic
  end
  ## TODO? check argument types
  procData [] .procType .inTypes .elements [] .length program offsetStack =:: oldNameOffset =:: oldOffset
  procData [] .implementation switch
    code case ## TODO? ensure proc-body is type-checked
      program [] .currentProcScope =:: prevProc
      program openScope ## TODO! evaluate procedures in scope at declaration position
      program [] .currentScope program .currentProcScope=
      procData .implementation [] .code program evaluateBlock
      program closeScope
      prevProc program .currentProcScope=
      break
    builtIn case
      procData .implementation [] .builtIn program evaluateBuiltIn
      break
  end
  oldOffset oldNameOffset program resetStack
end
proc( Token slice : tokens BlockType : blockType Program ptr.mut : program -> Type ) =>: evaluateTypeBlock
  0:iSize program offsetStack =:: oldNameOffset =:: oldOffset
  program [] .mode =:: oldMode
  InterpreterMode .TYPE_BLOCK program .mode=
  program [] .stackOffset =:: baseOffset
  program [] .nameStackOffset =:: baseNameOffset
  tokens program evaluateBlock
  program [] .stackOffset baseOffset u>= "stack offset did not shrink" assert
  program [] .stackOffset baseOffset - =:: argCount
  program [] .nameStackOffset baseNameOffset u>= "name stack offset did not shrink" assert
  program [] .nameStackOffset baseNameOffset - =:: argNameCount
  program [] .nameStack list.asSlice baseNameOffset slice.tail =:: eltNames0
  program [] .stack
    $ list.asSlice baseOffset slice.tail =:: tupleElts0
    program [] .memory
      tupleElts0 .length 0:iSize == if
        Type slice.emptyMutable
      else
        tupleElts0 .length i32 cast Type mixedArena.allocSlice
      end =:: tupleElts
      eltNames0 .length 0:iSize == if
        ElementLabel slice.empty
      else
        eltNames0 .length tupleElts0 .length u<= "at least one element per label" assert
        tupleElts0 .length i32 cast ElementLabel mixedArena.allocSlice =:: eltNames1
        eltNames1 .data eltNames0 .data eltNames0 .length mem.copy ..drop
        eltNames0 .length while $ eltNames1 .length u< do =:: i
          ElementLabel .None eltNames1 i =[]
        finally i 1:iSize + end ..drop
        eltNames1 slice.freeze
      end =:: eltNames
      0:iSize =:: mut: i
      tupleElts0 for .value .Type tupleElts i =[] i 1:iSize + i= end
      blockType .PROC_TYPE ?? if
        ## ProcedureType
          tupleElts argCount slice.head slice.freeze eltNames argNameCount slice.head CompositeType new
          tupleElts argCount slice.tail slice.freeze eltNames argNameCount slice.tail CompositeType new
        ProcedureType new mixedArena.copyValue Type .Procedure
      else
        tupleElts slice.freeze eltNames CompositeType new mixedArena.copyValue
        blockType .UNION_TYPE ?? if
          Type .Union
        else
          blockType .TUPLE_TYPE ?? "unexpected block-type" assert
          Type .Tuple
        end
      end =:: resType
    program .memory=
    baseOffset list.setLength
  program .stack=
  program [] .nameStack baseNameOffset list.setLength program .nameStack=
  oldOffset oldNameOffset program resetStack
  oldMode program .mode=
  resType return
end
proc( Token slice : tokens Program ptr.mut : program -> Value ) =>: evaluateInitializerBlock
  0:iSize program offsetStack =:: oldNameOffset =:: oldOffset
  program [] .mode =:: oldMode
  InterpreterMode .TYPE_BLOCK program .mode=
  program [] .stackOffset =:: baseOffset
  tokens program evaluateBlock
  program [] .stackOffset baseOffset == "stack offset did not change" assert
  program [] .stack
    $ list.asSlice baseOffset slice.tail =:: tupleElts0
    tupleElts0 .length Value rcSlice.create =:: resVal
    0:iSize =:: mut: i
    tupleElts0 for .value resVal i rcSlice.set i 1:iSize + i= end
    baseOffset list.setLength
  program .stack=
  oldOffset oldNameOffset program resetStack
  oldMode program .mode=
  resVal Value .Composite return
end
proc( string : name Program ptr.mut : program -> Identifier ptr.mut optional ) =>: findName
   program [] .currentNamespace sb.asStr =:: mut: prefix
   program [] .nameBuffer
     sb.clear
     prefix sb.appendStr
     $ .length 0:iSize != if '.' sb.appendC end
     name sb.appendStr
   program .nameBuffer=
   program [] .currentScope =:: mut: scopeId
   scopeId ScopeId.GLOBAL != if
     program [] .nameBuffer sb.asStr =:: fullName
     program .identifiers fullName program [] .currentFile scopeId IdName new map.at
     $ optional.hasData if return end ..drop
     program [] .scopeStack .length 1:iSize - while =:: i i -1:iSize != and
       program [] .scopeStack i [] scopeId=
       scopeId program [] .currentProcScope !=
     do
       program .identifiers fullName program [] .currentFile scopeId IdName new map.at
       $ optional.hasData if return end ..drop
     finally i 1:iSize - end
   end
   while
     program [] .nameBuffer sb.asStr =:: fullName
     program .identifiers fullName program [] .currentFile ScopeId.GLOBAL IdName new map.at
     $ optional.hasData if return end ..drop
     program .identifiers fullName FileId.GLOBAL ScopeId.GLOBAL IdName new map.at
     $ optional.hasData if return end ..drop
   prefix .length 0:iSize != do
     prefix '.' string.splitLast prefix= =:: tail
     program [] .nameBuffer
       $ .length tail .length name .length + 1:iSize + - sb.setLength ## remove <tail>.<name> fromBuffer
       name sb.appendStr
     program .nameBuffer=
   end
   Identifier ptr.mut optional.empty
end
proc( Program ptr.mut : program -> bool ) =>: getCondition
  1:iSize program checkStack if
    "stack underflow" ..panic
  end
  program [] .stack
    list.pop =:: cond
  program .stack=
  cond asBool
end
proc( Program ptr.mut : program -> ) =>: openScope
  program [] .scopeStack
    program [] .currentScope list.append
  program .scopeStack=
  program [] .scopeCounter
    $ i32 cast.u 1 + ScopeId cast.u program .scopeCounter=
  program .currentScope=
end
proc( Program ptr.mut : program -> ) =>: closeScope
  program [] .scopeStack
    $ .length 0:iSize != if
      list.pop program .currentScope=
    else
      "unexpected end of scope" ..panic
    end
  program .scopeStack=
end
proc( Token slice : tokens Program ptr.mut : program -> ) =>: evaluateBlock
  0:i32 =:: mut: ip
  while ip iSize cast.u tokens .length u< do
    tokens ip [] =:: token
    token switch
      Identifier case
        token .Identifier program findName =:: idData?
        idData? optional.isEmpty if
          "Unknown identifier: \"":s io.print
          token .Identifier io.print
          "\" in namespace \"":s io.print
          program [] .currentNamespace sb.asStr io.print
          "\"":s io.println
          break
        end
        idData? .data =:: idData
        ## TODO better way to distinguish procedures from procedure pointers
        idData .value .value [] .Procedure ?? and idData .value .valType [] .Procedure ?? if
          idData .value .value [] .Procedure program evaluateCall
        else
          program [] .stack
            idData [] .value useTypedValue list.append
          program .stack=
        end
        break
      Constant case
        program [] .stack
          token .Constant list.append
        program .stack=
        break
      Block case
        token .Block .blockType switch
          IF case
            program openScope
            program getCondition ! if
              ip token .Block .target + ip=
            end
            break
          DO case
            program getCondition ! if
              ip token .Block .target + ip=
            end
            break
          ELSE case
            program closeScope ## close if-scope before jump to end
            ip token .Block .target + ip=
            break
          UNION_TYPE TUPLE_TYPE PROC_TYPE case
            program openScope
            ## TypedValue
              ## evaluateTypeBlock
                tokens
                  ip 1 + iSize cast.u
                  token .Block .target iSize cast.u
                slice.getSlice
                token .Block .blockType
              program evaluateTypeBlock Value .Type
              Type .Type
            TypedValue new =:: newType
            program closeScope
            ## ! evaluateTypeBlock modifies stack -> cannot inline type-declaration
            program [] .stack
              newType list.append
            program .stack=
            ip token .Block .target + ip=
            break
          TO_TYPE case
            ## TODO should second half of proc-type have its own scope?
            ## ensure arguments do not interfer with return values
            0:iSize program offsetStack ..drop.2
            break
          INITIALIZER case
            program openScope
            ## TypedValue
              ## evaluateInitializerBlock
                tokens
                  ip 1 + iSize cast.u
                  token .Block .target iSize cast.u
                slice.getSlice
              program evaluateInitializerBlock
              Type .None
            TypedValue new =:: newVal
            program closeScope
            ## ! evaluateInitializerBlock modifies stack -> cannot inline type-declaration
            program [] .stack
              newVal list.append
            program .stack=
            ip token .Block .target + ip=
            break
          PROCEDURE case
            1:iSize program checkStack if
              "stack underflow" ..panic
            end
            program [] .stack
              list.pop asType =:: procType
            program .stack=
            ## TODO remember scope
            token .Block .target =:: procLength
            program [] .memory
              tokens ip 1 + procLength slice.getSlice mixedArena.copySlice =:: procBody
              procType .Procedure
                procBody slice.freeze ProcImplementation .code
              Procedure new mixedArena.copyValue =:: procPtr
            program .memory=
            program [] .stack
              procPtr Value .Procedure procType TypedValue new list.append
            program .stack=
            ip procLength + ip= ## skip procedure body
            break
          WHILE case
            program openScope
            break
        end
        break
      EndBlock case
        token .EndBlock .blockType .IF ?? or token .EndBlock .blockType .WHILE ?? if
          program closeScope
        end
        ip token .EndBlock .target + ip=
        break
      SetValue case
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        program [] .stack
          list.pop =:: value
        program .stack=
        token .SetValue program findName =:: prevData?
        prevData? optional.isEmpty or
            prevData? .data [] .modifiers IdModifier.MUTABLE & ? ! if
          "Error handling" ..panic
        else
          prevData? .data .value [] .value freeValue
          ## TODO type-checking
          value prevData? .data .value=
        end
        break
      Initialize case
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        program [] .mode .TYPE_BLOCK ?? or program [] .mode .INITIALIZER ?? if
          token .Initialize .initType .DECLARE ?? ! if
            "variables in initailizers are not supported" ..panic
          end
          program stackSize program nameStackSize - =:: unnamedValues
          program [] .nameStack
            unnamedValues 1:iSize u> if
              unnamedValues 1:iSize - for ..drop
                ElementLabel .None list.append
              end
            end
            ## Label
              token .Initialize .name
              token .Initialize .modifiers
            Label new ElementLabel .Label list.append
          program .nameStack=
          break
        end
        token .Initialize .initType .AUTO ?? ! if
          "Explicitly typed Variables are not supported" ..panic
        end
        program [] .stack
          list.pop =:: value
        program .stack=
        ## TODO ensure value is typed ( replace int literal with i32 and float literal with f64 )
        token .Initialize .name program findName =:: oldName?
        ## TODO handle shadowing
        oldName? optional.hasData if
          "Error handling" ..panic
        end
        token .Initialize .modifiers IdModifier.EXPORT & ? if
          FileId.GLOBAL
        else
          program [] .currentFile
        end =:: fileId
        fileId FileId.GLOBAL == or token .Initialize .modifiers IdModifier.GLOBAL & ? if
          ScopeId.GLOBAL
        else
          program [] .currentScope
        end =:: scopeId
        ## add current namespace before name
        program [] .currentNamespace
          $ .length =:: oldLength
          oldLength 0:iSize != if '.' sb.appendC end
          token .Initialize .name sb.appendStr
        program .currentNamespace=
        program [] .currentNamespace sb.asStr program copyName =:: fullName
        program [] .currentNamespace
          oldLength sb.setLength
        program .currentNamespace=
        program .identifiers
          fullName fileId scopeId IdName new
          value token .Initialize .modifiers Identifier new
        map.put ..drop
        break
      New case
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        program [] .stack
          list.pop asType =:: tupleType
        program .stack=
        tupleType .Array ?? if
          program [] .stack
            tupleType defaultValue tupleType TypedValue new list.push
          program .stack=
          break
        end
        tupleType .Tuple ?? ! if
          "error handling" ..panic
        end
        tupleType .Tuple .elements [] .length program checkStack if
          "stack underflow" ..panic
        end
        tupleType .Tuple .elements [] .length Value rcSlice.create =:: tupleData
        program [] .stack .length tupleType .Tuple .elements [] .length - =:: offset
        0:iSize =:: mut: index
        program [] .stack
          $ list.asSlice offset slice.tail for =:: elt
            ## TODO? check element type
            elt .value tupleData index rcSlice.set
            index 1:iSize + index=
          end
          offset list.setLength
          tupleData Value .Composite tupleType TypedValue new list.push
        program .stack=
        break
      GetElement SetElement GetNamedElement SetNamedElement case
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        token .SetElement ?? or token .SetNamedElement ?? end =:: setValue
        program [] .stack
          list.pop =:: composite
        program .stack=
        ## TODO check type
        composite .valType .None ?? ! and
            composite .valType .Tuple ?? ! and composite .valType .Array ?? ! if
          "error handling" ..panic
        end
        token switch
          SetElement case token .SetElement iSize cast.u optional.wrap break
          GetElement case token .GetElement iSize cast.u optional.wrap break
          SetNamedElement case composite token .SetNamedElement getElementIndex break
          GetNamedElement case composite token .GetNamedElement getElementIndex break
          default ..unreachable
        end =:: index?
        index? optional.isEmpty if
          "error handling" ..panic
        end
        index? .data =:: index
        composite .value .String ?? if
          setValue if "error handling" ..panic end ## TODO copy on write
          index composite .value .String .length iSize cast.u u>= if
            "error handling" ..panic
          end
          program [] .stack
            composite .value .String asString index string.charAt i64 cast.u Value .Int
            Type .Char8 TypedValue new list.append
          program .stack=
          break
        end
        composite .value .Composite ?? ! if
          "error handling" ..panic
        end
        index composite .value .Composite [] .length u>= if
          "error handling" ..panic
        end
        setValue ! if
          composite .valType .Tuple ?? if
            composite .valType .Tuple [] .elements index slice.get
          else
            composite .valType .Array [] .baseType
          end =:: eltType
          program [] .stack
            composite .value .Composite index rcSlice.get useValue
            eltType TypedValue new list.append
          program .stack=
          composite .value freeValue
          break
        end
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        program [] .stack
          list.pop =:: value
        program .stack=
        ## TODO? check element type
        composite .value .Composite [] .RC 1 == if ## only reference -> modify in place
          composite .value .Composite
        else
          composite .value index cloneValue .Composite
          composite .value .Composite rcSlice.free
        end =:: newElements
        value .value newElements index rcSlice.set
        program [] .stack
          newElements Value .Composite composite .valType TypedValue new list.append
        program .stack=
        break
      StackOp case
        token .StackOp switch
          Copy case
            token .StackOp .Copy iSize cast.u 1:iSize + =:: copyOffset
            copyOffset program checkStack if
              "stack underflow" ..panic
            end
            program [] .stack
              $ $ .length copyOffset - [] useTypedValue list.push
            program .stack=
            break
          Drop case
            token .StackOp .Drop iSize cast.u =:: toDrop
            toDrop program checkStack if
              "stack underflow" ..panic
            end
            program [] .stack
              $ .length toDrop - =:: newLength
              $ list.asSlice newLength slice.tail for .value freeValue end
              newLength list.setLength
            program .stack=
          break
          Rotate case
            token .StackOp .Rotate
              $ 0 < =:: reverse
              reverse if -_ end
            iSize cast.u 1:iSize + =:: count
            count program checkStack if
              "stack underflow" ..panic
            end
            reverse if ## rotate top element down
              program [] .stack $ .length 1:iSize - [] =:: hi
              program [] .stack $ .data >$ .length count - 1:iSize + @[]
                program [] .stack $ .data >$ .length count - @[]
                count 1:iSize -
              mem.move ..drop
              hi program [] .stack $ .length count - =[]
            else ## rotate element at positon count up
              program [] .stack $ .length count - [] =:: low
              program [] .stack $ .data >$ .length count - @[]
                program [] .stack $ .data >$ .length count - 1:iSize + @[]
                count 1:iSize -
              mem.move ..drop
              low program [] .stack $ .length 1:iSize - =[]
            end
            break
        end break
      NewArrayType case ## TODO? convert to built-in when there is overloading
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        ArraySize 4 array : sizeBuffer ## TODO switch to dynamic allocating if buffer is full
        sizeBuffer@ list.wrapBuffer =:: mut: sizes
        while program [] .stack list.peek .data .valType .Type ?? ! do
          program [] .stack
            list.pop =:: sizeVal
          program .stack=
          ## TODO support wildcard value for unsized pointers
          sizes
            sizeVal asInt ArraySize .Fixed list.push
          sizes=
          1:iSize program checkStack if
            "stack underflow" ..panic
          end
        end
        program [] .stack
          list.pop asType =:: mut: typeVal
        program .stack=
        sizes .length 0:iSize == if ## no explicit size -> implicit size of 1
          sizes 1 ArraySize .Fixed list.push sizes=
        end
        0:iSize while $ sizes .length 1:iSize - u< do =:: i
          sizes
            list.pop =:: nextSize
          sizes=
          typeVal nextSize program newArrayType Type .Array typeVal=
        finally i 1:iSize + end ..drop
        sizes list.pop =:: outerSize list.free sizes=
        program [] .stack
          typeVal outerSize program newArrayType
            token .NewArrayType switch
              ARRAY case Type .Array break
              POINTER case Type .Pointer break
              MUTABLE_POINTER case Type .MutablePointer break
            end
          Value .Type Type .Type TypedValue new list.append
        program .stack=
        break
      ArrayOperator case ## TODO make built-in functions once there is support for generics and overloading
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        program [] .stack
          list.pop =:: arg0
        program .stack=
        arg0 .value .Int ?? if
          program [] .stack
            list.pop =:: target
          program .stack=
          target
          arg0 .value .Int
        else
          arg0
          0
        end =:: index =:: target
        target .valType .Pointer ?? or target .valType .MutablePointer ?? end =:: isPointer
        target .valType .MutablePointer ?? =:: isMutablePointer
        target .valType .Array ?? if
          target .valType .Array [] .baseType
        else target .valType .Pointer ?? _if
          target .valType .Pointer [] .baseType
        else isMutablePointer _if
          target .valType .MutablePointer [] .baseType
        else target .valType .None ?? _if
          Type .None
        else
          "error handling" ..panic
        end =:: baseType
        token .ArrayOperator .SET ?? and target .valType .Pointer ?? if
          "error handling" ..panic ## cannot write to immutable pointer
        end
        token .ArrayOperator .AT ?? and isPointer ! if
          "error handling" ..panic ## cannot get pointer to array element
        end
        token .ArrayOperator .AT ?? and isMutablePointer if
          "unimplemented" ..panic ## mutable at (need notion of element pointer)
        end
        target .value .Composite ?? if
          target .value .Composite [] .length
        else target .value .String ?? _if
           target .value .String .length iSize cast.u
        else
          "error handling" ..panic
        end =:: size
        index iSize cast.u size u< "index in range" assert
        ## TODO add support for mutable element pointers
        token .ArrayOperator .SET ?? ! if
          ## TODO! how should reference count behave for pointers to elements of dynamically allocated values
          program [] .stack
            target .value .String ?? if
              target .value .String asString index string.charAt i64 cast.u Value .Int
            else
              target .value .Composite index iSize cast.u rcSlice.get useValue
            end
              baseType
              token .ArrayOperator .AT ?? if
                1 ArraySize .Fixed program newArrayType
                isMutablePointer if
                  Type .MutablePointer
                else
                  Type .Pointer
                end
              end
            TypedValue new list.append
          program .stack=
          target .value freeValue ## TODO should parent element of dynamic pointer be freed
          return
        end
        ## set element
        target .value .String ?? ! and isPointer or target .value .Composite [] .RC 1 == if ##  modify in place
          target .value .Composite
        else
          target .value index iSize cast.u cloneValue .Composite
          target .value freeValue
        end =:: newElements
        program [] .stack
          list.pop =:: newValue
        program .stack=
        ## TODO check type
        newValue .value newElements index iSize cast.u rcSlice.set
        isPointer ! if
          program [] .stack
            newElements Value .Composite target .valType TypedValue new list.append
          program .stack=
        end
        break
      ImportLocal ImportLib case
        importBuffer@ sb.wrapBuffer
          token .ImportLocal ?? if
            baseDir sb.appendStr '/' sb.appendC
            token .ImportLocal sb.appendStr
          else
            "library imports are not supported" ..panic
          end
          $ sb.asStr ".concat":s string.endsWith ! if
            ## TODO? don't append .concat if file has different extension
            ".concat":s sb.appendStr
          end
        sb.asStr =:: filePath
        filePath program importFile
        break
      BeginNamespace case
        program [] .currentScope ScopeId.GLOBAL != if
          ## TODO is there a good way to resolve names when scoped variables can be in different namespaces
          ##  ->?  somehow link local namespace to scope (? pseudo-scope to notify name-resolver to search in parent namespace)
          ##  three types of ids on scope stack: scopeId, procScopeId, parentNamespace
          "error handling" ..panic ## namespaces are not allowed within scopes
        end
        program [] .currentNamespace
          $ .length 0:iSize != if '.' sb.appendC end
          token .BeginNamespace sb.appendStr
        program .currentNamespace=
        break
      EndNamespace case
        program [] .currentNamespace
          $ sb.asStr token .EndNamespace string.endsWith "closed namespace matches opened namespace" assert
          $ .length token .EndNamespace .length - sb.setLength
          $ .length 0:iSize != if
            sb.pop '.' == "namespace-sperator" assert
          end
        program .currentNamespace=
        break
      EOF case return
    end
  finally ip 1 + ip= end
end
proc( string : path Program ptr.mut : program -> ) =>: importFile
  program [] .imports for =:: oldPath
    oldPath path string.eq if return end ## already imported
  end
  path program copyName =:: fixedPath
  program [] .currentFile =:: oldFileId
  program [] .currentScope =:: oldScopeId
  program [] .currentProcScope =:: oldProcScopeId
  program [] .scopeCounter =:: oldScopeCounter
  ScopeId.GLOBAL program .currentScope=
  ScopeId.GLOBAL program .currentProcScope=
  0:ScopeId program .scopeCounter=
  program [] .imports
    $ .length FileId cast program .currentFile=
    fixedPath list.append
  program .imports=
  program .tokens [] .length =:: tokenOffset
  program [] .currentNamespace =:: oldNamespace
  128 sb.create program .currentNamespace= ## TODO? is there a way to avoid allocating a seperate buffer for each file
  ## TODO handle IO errors
  path io.OPEN_READ io.fopenStr ..drop =:: srcFile
  4096 sb.create
    srcFile sb.appendFile ..drop
    $ sb.asStr program parseLine if
      "error handling" ..panic
    end
  sb.free ..drop
  srcFile io.fclose ..drop
  program [] .tokens list.asSlice tokenOffset slice.tail program evaluateBlock
  oldFileId program .currentFile=
  oldScopeId program .currentScope=
  oldProcScopeId program .currentProcScope=
  oldScopeCounter program .scopeCounter=
  program [] .currentNamespace sb.free ..drop
  oldNamespace program .currentNamespace=
end

## TODO? move to library
proc.c( char8 _ ptr -> char8 _ ptr ) : extern: getenv
proc.c( char8 _ ptr -> i64 ) : extern: strlen
proc( -> string ) =>: currentDir
  "PWD" getenv =:: charPtr
  charPtr iPtr cast! 0:iPtr == if
    ## TODO? error message/ fallback directory
    string.empty return
  end
  charPtr $ strlen  iSize cast.u string new
end

5:iSize =:: MAX_ELTS
char8 1024 array : mut: importBuffer
string : mut: baseDir
proc( -> ) =>: main
  ## TODO allow passing root-file as argument
  currentDir baseDir=
  ## Program
    4096 mixedArena.create
    IdName.hash@ IdName.eq@ 1024 Identifier map.create
    128 TypedValue list.create
    0:iSize
    128 ElementLabel list.create
    0:iSize
    16 string list.create
    64 ScopeId list.create
    FileId.GLOBAL
    ScopeId.GLOBAL
    ScopeId.GLOBAL
    0:ScopeId
    128 BlockInfo list.create
    0 sb.create
    0 sb.create
    128 Token list.create
    0:i32
    InterpreterMode .RUN
  Program new =:: mut: program
  program@ initBuiltIns
  ## create fake file with empty name for REPL code
  program .imports
    $ .length FileId cast program@ .currentFile=
    string.empty list.append
  program@ .imports=
  256 sb.create =:: mut: lineBuffer
  while program .mode .STOPPED ?? ! do
    " >> ":s io.print
    lineBuffer readLine lineBuffer=
    0 program@ .parseOffset=
    while
      lineBuffer sb.asStr program@ parseLine
    do
      "... ":s io.print
      lineBuffer '\n' sb.appendC readLine lineBuffer=
    end
    lineBuffer sb.clear lineBuffer=
    program .tokens for printToken end
    ## TODO? type-check before interpreting
    program .tokens list.asSlice program@ evaluateBlock
    program .tokens list.clear program@ .tokens=
    program .stack .length MAX_ELTS u> if
      " ...":s io.print
    end
    program .stack list.asSlice
      $ .length MAX_ELTS u> if
        $ .length MAX_ELTS - slice.tail
      end
    for =:: elt
      ' ' io.print elt printTypedValue
    end
    '\n' io.print
  end
  lineBuffer sb.free ..drop
  ## TODO! free program
end
