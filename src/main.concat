import io
import stringIO
import numbers
import chars
using std.literals.

import "common.concat"
import "builtIns.concat"

proc( stringBuilder -> stringBuilder ) =>: readLine
  while
    io.getChar ..drop =:: mut: c
    c '\n' !=
  do
    c sb.appendC
  end
end

proc( MixedArenaAllocator ptr.mut : alloc string : str -> string ) =>: copyString
  alloc [] str string.chars mixedArena.copySlice slice.freeze string.fromChars >$ alloc =[]
end

proc( string : mut: expr -> i32 IdModifier string ) =>: parseDeclaration
  0 =:: mut: i
  0 =:: mut: i0
  IdModifier.NONE =:: mut: modifiers
  while
    expr i string.tail expr=
    ## skip leading spaces
    0 i=
    while i iSize cast.u expr .length u< and expr i string.charAt char.isSpace do i 1 + i= end
    expr .length 0:iSize == if
      i0 modifiers string.empty return
    end
    i0 i + i0=
    expr i string.tail expr=
    0 i=
    while i iSize cast.u expr .length u< and expr i string.charAt char.isSpace ! do
      i 1 + i=
    end
    i 0 == if
      i0 modifiers string.empty return
    end
    i0 i + i0=
    expr i 1 - string.charAt ':' ==
  do
    expr i 1 - string.head =:: modif
    modif "mut":s string.eq if
      modifiers IdModifier.MUTABLE | modifiers=
    end
  end
  i0 modifiers expr i string.head
end
proc( string : mut: next Program ptr.mut : program -> i32 Token ) =>: nextToken
  0 =:: mut: i0
  ## skip leading spaces
  while i0 iSize cast.u next .length u< and next i0 string.charAt char.isSpace do i0 1 + i0= end
  next i0 string.tail next=
  next .length 0:iSize == if
    i0 Token .EOF return
  end
  0 =:: mut: i
  while i iSize cast.u next .length u< and next i string.charAt char.isSpace ! do
    i 1 + i=
  end
  i0 i + 1 +
  next i string.head =:: word
  word .length 0:iSize != and word 0 string.charAt char.isDigit if
    word 0 number.tryParseInt switch
      NONE case Value .Int Type .None TypedValue new Token .Constant return
      UNSIGNED case ## TODO warning
        Value .Int Type .None TypedValue new Token .Constant return
      SIGN case "error handling" ..panic
      OVERFLOW case "error handling" ..panic
      default ..drop break
    end
    word 0 number.tryParseFloat switch
      NONE INT case
        Value .Float Type .None TypedValue new Token .Constant return
      default "error handling" ..panic
    end
  end
  word ":":s string.eq if
    next i string.tail parseDeclaration =:: name =:: idFlags +
      name .length 0:iSize == if ..drop i0 Token .EOF return end
    name idFlags InitType .DECLARE InitInfo new Token .Initialize return
  else word "=:":s string.eq _if
    next i string.tail parseDeclaration =:: name =:: idFlags +
      name .length 0:iSize == if ..drop i0 Token .EOF return end
    name idFlags InitType .TYPED InitInfo new Token .Initialize return
  else word "=::":s string.eq _if
    next i string.tail parseDeclaration =:: name =:: idFlags +
      name .length 0:iSize == if ..drop i0 Token .EOF return end
    name idFlags InitType .AUTO InitInfo new Token .Initialize return
  else word "$":s string.eq _if
    0 StackOp .Copy Token .StackOp return
  else word "$1":s string.eq _if
    1 StackOp .Copy Token .StackOp return
  else word ">$":s string.eq _if
    1 StackOp .Copy Token .StackOp return
  else word "..drop":s string.eq _if
    1 StackOp .Drop Token .StackOp return
  else word .length 1:iSize u> and word 0 string.charAt '.' == _if
    word $ .length 1:iSize - string.charAt '=' == =:: setValue
    word 1 string.tail
      setValue if $ .length 1:iSize - string.head end
    =:: eltName
    eltName 10 number.tryParseUInt switch
      NONE UNSIGNED case break
      default "error handling" ..panic
    end =:: eltId
    eltId setValue if Token .SetElement else Token .GetElement end return
  else word "new":s string.eq _if
    Token .New return
  else word "if":s string.eq _if
    program [] .openBlocks
      ## IfBlockInfo
        program [] .tokens .length i32 cast.u ## ifIndex
        -1 ## elseIndex
        false ## autoClose
      IfBlockInfo new BlockInfo .ifBlock list.push
    program .openBlocks=
    -1 BlockType .IF CodeBlock new Token .Block return
  else word "_if":s string.eq _if
    program [] .openBlocks
      ## IfBlockInfo
        program [] .tokens .length i32 cast.u ## ifIndex
        -1 ## elseIndex
        true ## autoClose
      IfBlockInfo new BlockInfo .ifBlock list.push
    program .openBlocks=
    -1 BlockType .IF CodeBlock new Token .Block return
  else word "else":s string.eq _if
    program [] .openBlocks list.peek =:: ifBlock?
    ifBlock? .data .ifBlock =:: ifBlock
    program [] .tokens .length i32 cast.u ifBlock .elseIndex=
    ifBlock [] .ifIndex =:: ifIndex
    program [] .tokens .length i32 cast.u ifIndex -
      program [] .tokens ifIndex @[]
    .Block .target=
    -1 BlockType .ELSE CodeBlock new Token .Block return
  else word "while":s string.eq _if
    program [] .openBlocks
      ## WhileBlockInfo
        program [] .tokens .length i32 cast.u ## whileIndex
        -1 ## doIndex
      WhileBlockInfo new BlockInfo .whileBlock list.push
    program .openBlocks=
    0 BlockType .WHILE CodeBlock new Token .Block return
  else word "do":s string.eq _if
    program [] .openBlocks list.peek =:: whileBlock?
    whileBlock? .data .whileBlock =:: whileBlock
    program [] .tokens .length i32 cast.u whileBlock .doIndex=
    -1 BlockType .DO CodeBlock new Token .Block return
  else word "finally":s string.eq _if
    "unimplemented" ..panic
  else word "break":s string.eq _if
    "unimplemented" ..panic
  else word "continue":s string.eq _if
    "unimplemented" ..panic
  else word "=>":s string.eq or word "=>:":s string.eq _if
    word .length 3:iSize == if
      next i string.tail parseDeclaration =:: name =:: idFlags +
        name .length 0:iSize == if ..drop i0 Token .EOF return end
      name idFlags
    else
      string.empty IdModifier.NONE
    end =:: idFlags =:: name
    program [] .openBlocks
      ## ProcedureBlockInfo
        name ## procName
        program [] .tokens .length i32 cast.u ## blockStart
        idFlags ## idModifiers
      ProcedureBlockInfo new BlockInfo .procedureBlock list.push
    program .openBlocks=
    -1 BlockType .PROCEDURE CodeBlock new Token .Block return
  else word "end":s string.eq _if
    program [] .openBlocks .length 0:iSize == if
      "error handling" ..panic
    end
    program [] .openBlocks
      list.pop =:: closed
    program .openBlocks=
    closed switch
      ifBlock case
        closed .ifBlock .elseIndex =:: elseIndex
        elseIndex -1 == if ## no (explicit) else
          closed .ifBlock .ifIndex =:: ifIndex
          program [] .tokens .length i32 cast.u ifIndex -
            program [] .tokens ifIndex @[]
          .Block .target=
          program [] .tokens
            1 BlockType .ELSE CodeBlock new Token .Block list.append
          program .tokens=
        else
          program [] .tokens .length i32 cast.u elseIndex -
            program [] .tokens elseIndex @[]
          .Block .target=
        end
        0 BlockType .IF CodeBlock new Token .EndBlock return
      whileBlock case
        closed .whileBlock .whileIndex =:: whileIndex
        closed .whileBlock .doIndex =:: doIndex
        doIndex -1 == if ## no (explicit) do
          program [] .tokens
            1 BlockType .DO CodeBlock new Token .Block list.append
          program .tokens=
        else
          program [] .tokens .length i32 cast.u doIndex -
            program [] .tokens doIndex @[]
          .Block .target=
        end
        whileIndex program [] .tokens .length i32 cast.u -
          BlockType .WHILE
        CodeBlock new Token .EndBlock return
      procedureBlock case
        closed .procedureBlock .blockStart =:: blockStart
        program [] .tokens .length i32 cast.u blockStart -
          program [] .tokens blockStart @[]
        .Block .target=
        0 BlockType .PROCEDURE CodeBlock new Token .EndBlock =:: blockEnd
        closed .procedureBlock .procName .length 0:iSize == if
          blockEnd return
        end
        program [] .tokens blockEnd list.append program .tokens=
        closed .procedureBlock .procName
          closed .procedureBlock .idModifiers
        InitType .AUTO InitInfo new Token .Initialize return
      compositeBlock case "error handling" ..panic
    end
  else word "(":s string.eq _if
    program [] .openBlocks
      ## CompositeBlockInfo
        program [] .tokens .length i32 cast.u ## blockStart
        -1 ## toIndex
        CompositeBlockType .NONE
      CompositeBlockInfo new BlockInfo .compositeBlock list.push
    program .openBlocks=
    -1 BlockType .TUPLE_TYPE CodeBlock new Token .Block return
  else word "proc(":s string.eq _if
    program [] .openBlocks
      ## CompositeBlockInfo
        program [] .tokens .length i32 cast.u ## blockStart
        -1 ## toIndex
        CompositeBlockType .PROC
      CompositeBlockInfo new BlockInfo .compositeBlock list.push
    program .openBlocks=
    -1 BlockType .PROC_TYPE CodeBlock new Token .Block return
  else word "struct(":s string.eq _if
    program [] .openBlocks
      ## CompositeBlockInfo
        program [] .tokens .length i32 cast.u ## blockStart
        -1 ## toIndex
        CompositeBlockType .TUPLE
      CompositeBlockInfo new BlockInfo .compositeBlock list.push
    program .openBlocks=
    -1 BlockType .TUPLE_TYPE CodeBlock new Token .Block return
  else word "->":s string.eq _if
    program [] .openBlocks list.peek =:: procBlock?
    procBlock? .data .compositeBlock =:: procBlock
    procBlock .compType [] .NONE ?? if
      BlockType .PROC_TYPE program [] .tokens procBlock [] .blockStart @[] .Block .blockType=
      CompositeBlockType .PROC procBlock .compType=
    else procBlock .compType [] .PROC ?? ! or procBlock [] .toIndex -1 != _if
      "error handling" ..panic
    end
    program [] .tokens .length i32 cast.u procBlock .toIndex=
    0 BlockType .TO_TYPE CodeBlock new Token .Block return
  else word ")":s string.eq _if
    program [] .openBlocks .length 0:iSize == if
      "error handling" ..panic
    end
    program [] .openBlocks
      list.pop =:: closed
    program .openBlocks=
    closed .compositeBlock ?? ! if
      "error handling" ..panic
    end
    closed .compositeBlock .blockStart =:: startIndex
    program [] .tokens .length i32 cast.u startIndex -
      program [] .tokens startIndex @[]
    .Block .target=
    closed .compositeBlock .compType switch
      NONE TUPLE case BlockType .TUPLE_TYPE break
      PROC case
        closed .compositeBlock .toIndex =:: toIndex
        program [] .tokens .length i32 cast.u toIndex -
          program [] .tokens toIndex @[]
        .Block .target=
        BlockType .PROC_TYPE break
    end =:: blockType
    0 blockType CodeBlock new Token .EndBlock return
  end
  word .length 2:iSize u>= and word $ .length 1:iSize - string.charAt '=' == and
      word .length 2:iSize u> or "<>=!":s word 0 string.charAt string.contains ! if
    program .memory word $ .length 1:iSize - string.head copyString Token .SetValue return
  end
  program .memory word copyString Token .Identifier
end
## parse a single line returns true if line needs to be continued
proc( string : line Program ptr.mut : program -> bool ) =>: parseLine
  line "exit":s string.eq if
    false program .running=
    false return
  end
  while
    line program [] .parseOffset string.tail program nextToken =:: token =:: consumed
    program [] .parseOffset consumed + program .parseOffset=
    token .EOF ?? !
  do
    program [] .tokens
      token list.append
    program .tokens=
  end
  program [] .parseOffset iSize cast.u line .length u< or
      program [] .openBlocks .length 0:iSize != if
    true return
  end
  program [] .tokens for printToken end
  ## TODO? type-check before interpreting
  program [] .tokens list.asSlice program evaluateBlock
  false return
end

proc( Procedure ptr : procData Program ptr.mut : program -> ) =>: evaluateCall
  procData [] .procType .inTypes .elements [] .length program checkStack if
    "stack underflow" ..panic
  end
  ## TODO? check argument types
  procData [] .procType .inTypes .elements [] .length program offsetStack =:: oldOffset
  procData [] .implementation switch
    code case ## TODO? ensure proc-body is type-checked
      procData .implementation [] .code program evaluateBlock
      break
    builtIn case
      procData .implementation [] .builtIn program evaluateBuiltIn
      break
  end
  oldOffset program resetStack
end
proc( Token slice : tokens bool : isProc Program ptr.mut : program -> Type ) =>: evaluateTypeBlock
  0:iSize program offsetStack =:: oldOffset
  program [] .stackOffset =:: baseOffset
  ## TODO? seperate interpreter mode for correct handling of named declarations
  tokens program evaluateBlock
  program [] .stackOffset baseOffset u>= "stack offset did not shrink" assert
  program [] .stackOffset baseOffset - =:: argCount
  program [] .stack
    $ list.asSlice baseOffset slice.tail =:: tupleElts0
    program [] .memory
      tupleElts0 .length i32 cast Type mixedArena.allocSlice =:: tupleElts
      0:iSize =:: mut: i
      tupleElts0 for .value .Type tupleElts i =[] i 1:iSize + i= end
      isProc if
        ## ProcedureType
          tupleElts argCount slice.head slice.freeze CompositeType new
          tupleElts argCount slice.tail slice.freeze CompositeType new
        ProcedureType new mixedArena.copyValue Type .Procedure
      else
        tupleElts slice.freeze CompositeType new mixedArena.copyValue Type .Tuple
      end =:: resType
    program .memory=
    baseOffset list.setLength
  program .stack=
  oldOffset program resetStack
  resType return
end
proc( Token slice : tokens Program ptr.mut : program -> ) =>: evaluateBlock
  0:i32 =:: mut: ip
  while ip iSize cast.u tokens .length u< do
    tokens ip [] =:: token
    token switch
      Identifier case
        program .identifiers token .Identifier map.get =:: idData?
        idData? optional.isEmpty if
          "Unknown identifier: \"":s io.print
          token .Identifier io.print
          "\"":s io.println
          return
        end
        idData? .data =:: idData
        ## TODO better way to distinguish procedures from procedure pointers
        idData .value .value .Procedure ?? and idData .value .valType .Procedure ?? if
          idData .value .value .Procedure program evaluateCall
        else
          program [] .stack
            idData .value useTypedValue list.append
          program .stack=
        end
        break
      Constant case
        program [] .stack
          token .Constant list.append
        program .stack=
        break
      Block case
        token .Block .blockType switch
          IF DO case
            1:iSize program checkStack if
              "stack underflow" ..panic
            end
            program [] .stack
              list.pop =:: cond
            program .stack=
            cond asBool ! if
              ip token .Block .target + ip=
            end
            break
          ELSE case ip token .Block .target + ip= break
          TUPLE_TYPE PROC_TYPE case
            ## TypedValue
              ## evaluateTypeBlock
                tokens
                  ip 1 + iSize cast.u
                  token .Block .target iSize cast.u
                slice.getSlice
                token .Block .blockType .PROC_TYPE ??
              program evaluateTypeBlock Value .Type
              Type .Type
            TypedValue new =:: newType
            ## ! evaluateTypeBlock modifies stack -> cannot inline type-declaration
            program [] .stack
              newType list.append
            program .stack=
            ip token .Block .target + ip=
            break
          TO_TYPE case
            ## ensure arguments do not interfer with return values
            0:iSize program offsetStack ..drop
            break
          PROCEDURE case
            1:iSize program checkStack if
              "stack underflow" ..panic
            end
            program [] .stack
              list.pop asType =:: procType
            program .stack=
            token .Block .target =:: procLength
            program [] .memory
              tokens ip 1 + procLength slice.getSlice mixedArena.copySlice =:: procBody
              procType .Procedure
                procBody slice.freeze ProcImplementation .code
              Procedure new mixedArena.copyValue =:: procPtr
            program .memory=
            program [] .stack
              procPtr Value .Procedure procType TypedValue new list.append
            program .stack=
            ip procLength + ip= ## skip procedure body
            break
          WHILE case break ## nothing to do
        end
        break
      EndBlock case
        ip token .EndBlock .target + ip=
        break
      SetValue case
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        program [] .stack
          list.pop =:: value
        program .stack=
        program .identifiers token .SetValue map.at =:: prevData?
        prevData? optional.isEmpty or
            prevData? .data [] .modifiers IdModifier.MUTABLE & ? ! if
          "Error handling" ..panic
        else
          prevData? .data .value [] .value freeValue
          ## TODO type-checking
          value prevData? .data .value=
        end
        break
      Initialize case
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        token .Initialize .initType .AUTO ?? ! if
          "Explicitly typed Variables are not supported" ..panic
        end
        program [] .stack
          list.pop =:: value
        program .stack=
        ## TODO ensure value is typed ( replace int literal with i32 and float literal with f64 )
        program .identifiers
          token .Initialize .name
          value token .Initialize .modifiers Identifier new
        map.put =:: prevData?
        prevData? optional.hasData if
          program .identifiers token .Initialize .name prevData? .data map.put ..drop
          "Error handling" ..panic
        end
        break
      New case
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        program [] .stack
          list.pop asType =:: tupleType
        program .stack=
        tupleType .Array ?? if
          program [] .stack
            tupleType defaultValue tupleType TypedValue new list.push
          program .stack=
          return
        end
        tupleType .Tuple ?? ! if
          "error handling" ..panic
        end
        tupleType .Tuple .elements [] .length program checkStack if
          "stack underflow" ..panic
        end
        tupleType .Tuple .elements [] .length Value rcSlice.create =:: tupleData
        program [] .stack .length tupleType .Tuple .elements [] .length - =:: offset
        0:iSize =:: mut: index
        program [] .stack
          $ list.asSlice offset slice.tail for =:: elt
            ## TODO? check element type
            elt .value tupleData index rcSlice.set
            index 1:iSize + index=
          end
          offset list.setLength
          tupleData Value .Composite tupleType TypedValue new list.push
        program .stack=
        break
      GetElement SetElement case
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        token .SetElement ?? =:: setValue
        program [] .stack
          list.pop =:: tuple
        program .stack=
        ## TODO? check type
        tuple .valType .Tuple ?? ! or tuple .value .Composite ?? ! if
          "error handling" ..panic
        end
        setValue if token .SetElement else token .GetElement end =:: index
        index tuple .value .Composite [] .length i64 cast.u u>= if
          "error handling" ..panic
        end
        setValue ! if
          tuple .value .Composite [] .length i64 cast.u for =:: i
            i index == if continue end
            tuple .value .Composite i iSize cast.u rcSlice.get freeValue
          end
          program [] .stack
            tuple .value .Composite index iSize cast.u rcSlice.get
            tuple .valType .Tuple [] .elements index slice.get TypedValue new list.append
          program .stack=
          return
        end
        1:iSize program checkStack if
          "stack underflow" ..panic
        end
        program [] .stack
          list.pop =:: value
        program .stack=
        ## TODO? check element type
        tuple .value .Composite [] .RC 1 == if ## only reference -> modify in plane
          tuple .value .Composite
        else
          tuple .value .Composite [] .length Value rcSlice.create =:: copy
          tuple .value .Composite [] .length i64 cast.u for =:: i
            i index == if continue end
            tuple .value .Composite i iSize cast.u rcSlice.get
            copy i iSize cast.u rcSlice.set
          end
          tuple .value .Composite rcSlice.free
          copy
        end =:: newTuple
        value .value newTuple index iSize cast.u rcSlice.set
        program [] .stack
          newTuple Value .Composite tuple .valType TypedValue new list.append
        program .stack=
        return
      StackOp case
        token .StackOp switch
          Copy case
            token .StackOp .Copy iSize cast.u 1:iSize + =:: copyOffset
            copyOffset program checkStack if
              "stack underflow" ..panic
            end
            program [] .stack
              $ $ .length copyOffset - [] useTypedValue list.push
            program .stack=
            break
          Drop case
            token .StackOp .Drop iSize cast.u =:: toDrop
            toDrop program checkStack if
              "stack underflow" ..panic
            end
            program [] .stack
              $ .length toDrop - =:: newLength
              $ list.asSlice newLength slice.tail for .value freeValue end
              newLength list.setLength
            program .stack=
          break
          Rotate case
            token .StackOp .Rotate
              $ 0 < =:: reverse
              reverse if -_ end
            iSize cast.u 1:iSize + =:: count
            count program checkStack if
              "stack underflow" ..panic
            end
            reverse if ## rotate top element down
              program [] .stack $ .length 1:iSize - [] =:: hi
              program [] .stack $ .data >$ .length count - @[]
                program [] .stack $ .data >$ .length count - 1:iSize + @[]
                count 1:iSize -
              mem.move ..drop
              hi program [] .stack $ .length count - =[]
            else ## rotate element at positon count up
              program [] .stack $ .length count - [] =:: low
              program [] .stack $ .data >$ .length count - 1:iSize + @[]
                program [] .stack $ .data >$ .length count - @[]
                count 1:iSize -
              mem.move ..drop
              low program [] .stack $ .length 1:iSize - =[]
            end
            break
        end break
      EOF case return
    end
  finally ip 1 + ip= end
end

5:iSize =:: MAX_ELTS
proc( -> ) =>: main
  ## Program
    4096 mixedArena.create
    string.hash@ string.eq@ 1024 Identifier map.create
    128 TypedValue list.create
    0:iSize
    128 BlockInfo list.create
    128 Token list.create
    0:i32
    true
  Program new =:: mut: program
  program@ initBuiltIns
  256 sb.create =:: mut: lineBuffer
  while program .running do
    " >> ":s io.print
    lineBuffer readLine lineBuffer=
    0 program@ .parseOffset=
    while
      lineBuffer sb.asStr program@ parseLine
    do
      "... ":s io.print
      lineBuffer '\n' sb.appendC readLine lineBuffer=
    end
    lineBuffer sb.clear lineBuffer=
    program .tokens list.clear program@ .tokens=
    program .stack .length MAX_ELTS u> if
      " ...":s io.print
    end
    program .stack list.asSlice
      $ .length MAX_ELTS u> if
        $ .length MAX_ELTS - slice.tail
      end
    for =:: elt
      ' ' io.print elt printTypedValue
    end
    '\n' io.print
  end
  lineBuffer sb.free ..drop
end
