import io
import stringIO
import numbers
import chars
using std.literals.

import "common.concat"
import "builtIns.concat"

proc( stringBuilder -> stringBuilder ) =>: readLine
  while
    io.getChar ..drop =:: mut: c
    c '\n' !=
  do
    c sb.appendC
  end
end

proc( MixedArenaAllocator ptr.mut : alloc string : str -> string ) =>: copyString
  alloc [] str string.chars mixedArena.copySlice slice.freeze string.fromChars >$ alloc =[]
end

proc( string : mut: expr -> i32 IdModifier string ) =>: parseDeclaration
  0 =:: mut: i
  0 =:: mut: i0
  IdModifier.NONE =:: mut: modifiers
  while
    expr i string.tail expr=
    ## skip leading spaces
    0 i=
    while i iSize cast.u expr .length u< and expr i string.charAt char.isSpace do i 1 + i= end
    expr .length 0:iSize == if
      i0 modifiers string.empty return
    end
    i0 i + i0=
    expr i string.tail expr=
    0 i=
    while i iSize cast.u expr .length u< and expr i string.charAt char.isSpace ! do
      i 1 + i=
    end
    i 0 == if
      i0 modifiers string.empty return
    end
    i0 i + i0=
    expr i 1 - string.charAt ':' ==
  do
    expr i 1 - string.head =:: modif
    modif "mut":s string.eq if
      modifiers IdModifier.MUTABLE | modifiers=
    end
  end
  i0 modifiers expr i string.head
end
proc( string : mut: next Program ptr.mut : program -> i32 Token ) =>: nextToken
  0 =:: mut: i0
  ## skip leading spaces
  while i0 iSize cast.u next .length u< and next i0 string.charAt char.isSpace do i0 1 + i0= end
  next i0 string.tail next=
  next .length 0:iSize == if
    i0 Token .EOF return
  end
  0 =:: mut: i
  while i iSize cast.u next .length u< and next i string.charAt char.isSpace ! do
    i 1 + i=
  end
  i0 i + 1 +
  next i string.head =:: word
  word .length 0:iSize != and word 0 string.charAt char.isDigit if
    word 0 number.tryParseInt switch
      NONE case Token .Integer return
      UNSIGNED case ## TODO warning
        Token .Integer return
      SIGN case "error handling" ..panic
      OVERFLOW case "error handling" ..panic
      default ..drop break
    end
    word 0 number.tryParseFloat switch
      NONE INT case Token .Float return
      default "error handling" ..panic
    end
  end
  word ":":s string.eq if
    next i string.tail parseDeclaration =:: name =:: idFlags +
      name .length 0:iSize == if ..drop i0 Token .EOF return end
    name idFlags InitInfo new Token .Declare return
  else word "=:":s string.eq _if
    next i string.tail parseDeclaration =:: name =:: idFlags +
      name .length 0:iSize == if ..drop i0 Token .EOF return end
    name idFlags InitInfo new Token .TypedInitialize return
  else word "=::":s string.eq _if
    next i string.tail parseDeclaration =:: name =:: idFlags +
      name .length 0:iSize == if ..drop i0 Token .EOF return end
    name idFlags InitInfo new Token .Initialize return
  else word "if":s string.eq _if
    program [] .openBlocks
      ## IfBlockInfo
        program [] .tokens .length i32 cast.u ## ifIndex
        -1 ## elseIndex
        false ## autoClose
      IfBlockInfo new BlockInfo .ifBlock list.push
    program .openBlocks=
    -1 BlockType .IF CodeBlock new Token .Block return
  else word "_if":s string.eq _if
    program [] .openBlocks
      ## IfBlockInfo
        program [] .tokens .length i32 cast.u ## ifIndex
        -1 ## elseIndex
        true ## autoClose
      IfBlockInfo new BlockInfo .ifBlock list.push
    program .openBlocks=
    -1 BlockType .IF CodeBlock new Token .Block return
  else word "else":s string.eq _if
    program [] .openBlocks list.peek =:: ifBlock?
    ifBlock? .data .ifBlock =:: ifBlock
    program [] .tokens .length i32 cast.u ifBlock .elseIndex=
    ifBlock [] .ifIndex =:: ifIndex
    program [] .tokens .length i32 cast.u ifIndex -
      program [] .tokens ifIndex @[]
    .Block .target=
    -1 BlockType .ELSE CodeBlock new Token .Block return
  else word "while":s string.eq _if
    program [] .openBlocks
      ## WhileBlockInfo
        program [] .tokens .length i32 cast.u ## whileIndex
        -1 ## doIndex
      WhileBlockInfo new BlockInfo .whileBlock list.push
    program .openBlocks=
    0 BlockType .WHILE CodeBlock new Token .Block return
  else word "do":s string.eq _if
    program [] .openBlocks list.peek =:: whileBlock?
    whileBlock? .data .whileBlock =:: whileBlock
    program [] .tokens .length i32 cast.u whileBlock .doIndex=
    -1 BlockType .DO CodeBlock new Token .Block return
  else word "finally":s string.eq _if
    "unimplemented" ..panic
  else word "break":s string.eq _if
    "unimplemented" ..panic
  else word "continue":s string.eq _if
    "unimplemented" ..panic
  else word "end":s string.eq _if
    program [] .openBlocks
      list.pop =:: closed
    program .openBlocks=
    ## TODO handle closed block (insert correct jump-distances into operations
    closed switch
      ifBlock case
        closed .ifBlock .elseIndex =:: elseIndex
        elseIndex -1 == if ## no (explicit) else
          closed .ifBlock .ifIndex =:: ifIndex
          program [] .tokens .length i32 cast.u ifIndex -
            program [] .tokens ifIndex @[]
          .Block .target=
          program [] .tokens
            1 BlockType .ELSE CodeBlock new Token .Block list.append
          program .tokens=
        else
          program [] .tokens .length i32 cast.u elseIndex -
            program [] .tokens elseIndex @[]
          .Block .target=
        end
        0 BlockType .IF CodeBlock new Token .EndBlock return
      whileBlock case
        closed .whileBlock .whileIndex =:: whileIndex
        closed .whileBlock .doIndex =:: doIndex
        doIndex -1 == if ## no (explicit) do
          program [] .tokens
            1 BlockType .DO CodeBlock new Token .Block list.append
          program .tokens=
        else
          program [] .tokens .length i32 cast.u doIndex -
            program [] .tokens doIndex @[]
          .Block .target=
        end
        whileIndex program [] .tokens .length i32 cast.u -
          BlockType .WHILE
        CodeBlock new Token .EndBlock return
      compositeBlock case "error handling" ..panic
    end
  else word "(":s string.eq _if
    program [] .openBlocks
      ## CompositeBlockInfo
        program [] .tokens .length i32 cast.u ## blockStart
        -1 ## toIndex
        CompositeType .NONE
      CompositeBlockInfo new BlockInfo .compositeBlock list.push
    program .openBlocks=
    -1 BlockType .TUPLE CodeBlock new Token .Block return
  else word "proc(":s string.eq _if
    program [] .openBlocks
      ## CompositeBlockInfo
        program [] .tokens .length i32 cast.u ## blockStart
        -1 ## toIndex
        CompositeType .PROC
      CompositeBlockInfo new BlockInfo .compositeBlock list.push
    program .openBlocks=
    -1 BlockType .PROC CodeBlock new Token .Block return
  else word "struct(":s string.eq _if
    program [] .openBlocks
      ## CompositeBlockInfo
        program [] .tokens .length i32 cast.u ## blockStart
        -1 ## toIndex
        CompositeType .TUPLE
      CompositeBlockInfo new BlockInfo .compositeBlock list.push
    program .openBlocks=
    -1 BlockType .TUPLE CodeBlock new Token .Block return
  else word "->":s string.eq _if
    program [] .openBlocks list.peek =:: procBlock?
    procBlock? .data .compositeBlock =:: procBlock
    procBlock .compType [] .NONE ?? if
      BlockType .PROC program [] .tokens procBlock [] .blockStart @[] .Block .blockType=
      CompositeType .PROC procBlock .compType=
    else procBlock .compType [] .PROC ?? ! or procBlock [] .toIndex -1 != _if
      "error handling" ..panic
    end
    program [] .tokens .length i32 cast.u procBlock .toIndex=
    0 BlockType .TO CodeBlock new Token .Block return
  else word ")":s string.eq _if
    program [] .openBlocks
      list.pop =:: closed
    program .openBlocks=
    closed .compositeBlock ?? ! if
      "error handling" ..panic
    end
    closed .compositeBlock .blockStart =:: startIndex
    program [] .tokens .length i32 cast.u startIndex -
      program [] .tokens startIndex @[]
    .Block .target=
    closed .compositeBlock .compType switch
      NONE TUPLE case BlockType .TUPLE break
      PROC case
        closed .compositeBlock .toIndex =:: toIndex
        program [] .tokens .length i32 cast.u toIndex -
          program [] .tokens toIndex @[]
        .Block .target=
        BlockType .PROC break
    end =:: blockType
    0 blockType CodeBlock new Token .EndBlock return
  end
  word .length 2:iSize u>= and word $ .length 1:iSize - string.charAt '=' == and
      word .length 2:iSize u> or "<>=!":s word 0 string.charAt string.contains ! if
    program .memory word $ .length 1:iSize - string.head copyString Token .SetValue return
  end
  ## TODO? resolve identifiers outside procedures at parse time
  program .memory word copyString Token .Identifier
end
## parse a single line returns true if line needs to be continued
proc( string : line Program ptr.mut : program -> bool ) =>: parseLine
  line "exit":s string.eq if
    false program .running=
    false return
  end
  while
    line program [] .parseOffset string.tail program nextToken =:: token =:: consumed
    program [] .parseOffset consumed + program .parseOffset=
    token .EOF ?? !
  do ## TODO make sure to copy strings
    program [] .tokens
      token list.append
    program .tokens=
  end
  program [] .parseOffset iSize cast.u line .length u< or
      program [] .openBlocks .length 0:iSize != if
    true return
  end
  program [] .tokens for printToken end
  ## TODO? type-check before interpreting
  program [] .tokens list.asSlice program evaluateBlock
  false return
end

proc( ProcId : procId Program ptr.mut : program -> ) =>: evaluateCall
  program [] .procedures procId iSize cast.u [] =:: procData
  ## TODO? check arguments
  procData .implementation switch
    code case
      procData .implementation .code program evaluateBlock
      break
    builtIn case
      procData .implementation .builtIn program evaluateBuiltIn
      break
  end
end
proc( Token slice : tokens Program ptr.mut : program -> ) =>: evaluateBlock
  0:i32 =:: mut: ip
  while ip iSize cast.u tokens .length u< do
    tokens ip [] =:: token
    token switch
      Identifier case
        program .identifiers token .Identifier map.get =:: idData?
        idData? optional.isEmpty if
          "Unknown identifier: \"":s io.print
          token .Identifier io.print
          "\"":s io.println
          return
        end
        idData? .data =:: idData
        idData switch
          Variable case
            program [] .stack
              idData .Variable .value list.append
            program .stack=
            break
          Procedure case
            idData .Procedure program evaluateCall
            break
        end
        break
      Integer case
        program [] .stack
          token .Integer Value .Int Type .NONE TypedValue new list.append
        program .stack=
        break
      Float case "Floats are not supported" ..panic
      Block case
        token .Block .blockType switch
          IF DO case
            program [] .stack
              list.pop =:: cond
            program .stack=
            cond asBool ! if
              ip token .Block .target + ip=
            end
            break
          ELSE case ip token .Block .target + ip= break
          TUPLE PROC TO case ip token .Block .target + ip= break ## skip type-blocks (for now)
          WHILE case break ## nothing to do
        end
        break
      EndBlock case
        ip token .EndBlock .target + ip=
        break
      Declare TypedInitialize case
        "Explicitly typed Variables are not supported" ..panic
      SetValue case ## TODO! check mutability
        program [] .stack
          list.pop =:: value
        program .stack=
        program .identifiers token .SetValue map.at =:: prevData?
        prevData? optional.isEmpty or prevData? .data [] .Variable ?? ! or
            prevData? .data .Variable [] .modifiers IdModifier.MUTABLE & ? ! if
          "Error handling" ..panic
        else
          value prevData? .data .Variable .value=
        end
        break
      Initialize case
        program [] .stack
          list.pop =:: value
        program .stack=
        ## TODO ensure value is typed ( replace int literal with i32 and float literal with f64 )
        program .identifiers
          token .Initialize .name
          value token .Initialize .modifiers IdData new Identifier .Variable
        map.put =:: prevData?
        prevData? optional.hasData if
          program .identifiers token .Initialize .name prevData? .data map.put ..drop
          "Error handling" ..panic
        end
        break
      EOF case return
    end
  finally ip 1 + ip= end
end

5:iSize =:: MAX_ELTS
proc( -> ) =>: main
  ## Program
    4096 mixedArena.create
    128 Procedure list.create
    string.hash@ string.eq@ 1024 Identifier map.create
    128 TypedValue list.create
    128 BlockInfo list.create
    128 Token list.create
    0:i32
    true
  Program new =:: mut: program
  program@ initBuiltIns
  256 sb.create =:: mut: lineBuffer
  while program .running do
    " >> ":s io.print
    lineBuffer readLine lineBuffer=
    0 program@ .parseOffset=
    while
      lineBuffer sb.asStr program@ parseLine
    do
      "... ":s io.print
      lineBuffer '\n' sb.appendC readLine lineBuffer=
    end
    lineBuffer sb.clear lineBuffer=
    program .tokens list.clear program@ .tokens=
    program .stack .length MAX_ELTS u> if
      " ...":s io.print
    end
    program .stack list.asSlice
      $ .length MAX_ELTS u> if
        $ .length MAX_ELTS - slice.tail
      end
    for =:: elt
      ' ' io.print elt printTypedValue
    end
    '\n' io.print
  end
  lineBuffer sb.free ..drop
end
