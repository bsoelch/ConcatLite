import io
import stringIO
import numbers
import chars
using std.literals.

import "common.concat"
import "builtIns.concat"

proc( stringBuilder -> stringBuilder ) =>: readLine
  while
    io.getChar ..drop =:: mut: c
    c '\n' !=
  do
    c sb.appendC
  end
end

proc( MixedArenaAllocator ptr.mut : alloc string : str -> string ) =>: copyString
  alloc [] str string.chars mixedArena.copySlice slice.freeze string.fromChars >$ alloc =[]
end

proc( string : mut: next Program ptr.mut : program -> i32 Token ) =>: nextToken
  0 =:: mut: i0
  ## skip leading spaces
  while next .length 0:iSize != and next i0 string.charAt char.isSpace do i0 1 + i0= end
  next i0 string.tail next=
  next .length 0:iSize == if
    i0 Token .EOF return
  end
  0 =:: mut: i
  while i iSize cast.u next .length u< and next i string.charAt char.isSpace ! do
    i 1 + i=
  end
  i0 i + 1 +
  next i string.head =:: word
  word .length 0:iSize != and word 0 string.charAt char.isDigit if
    word 0 number.tryParseInt switch
      NONE case Token .Integer return
      UNSIGNED case ## TODO warning
        Token .Integer return
      SIGN case "error handling" ..panic
      OVERFLOW case "error handling" ..panic
      default ..drop break
    end
    word 0 number.tryParseFloat switch
      NONE INT case Token .Float return
      default "error handling" ..panic
    end
  end
  word "if":s string.eq if
    program [] .openBlocks
      ## IfBlockInfo
        program [] .tokens .length i32 cast.u ## ifIndex
        -1 ## elseIndex
        false ## autoClose
      IfBlockInfo new BlockInfo .ifBlock list.push
    program .openBlocks=
    -1 BlockType .IF CodeBlock new Token .Block return
  else word "_if":s string.eq _if
    program [] .openBlocks
      ## IfBlockInfo
        program [] .tokens .length i32 cast.u ## ifIndex
        -1 ## elseIndex
        true ## autoClose
      IfBlockInfo new BlockInfo .ifBlock list.push
    program .openBlocks=
    -1 BlockType .IF CodeBlock new Token .Block return
  else word "else":s string.eq _if
    program [] .openBlocks list.peek =:: ifBlock?
    ifBlock? .data .ifBlock =:: ifBlock
    program [] .tokens .length i32 cast.u ifBlock .elseIndex=
    ifBlock [] .ifIndex =:: ifIndex
    program [] .tokens .length i32 cast.u ifIndex -
      program [] .tokens ifIndex @[]
    .Block .target=
    -1 BlockType .ELSE CodeBlock new Token .Block return
  else word "while":s string.eq _if
    program [] .openBlocks
      ## WhileBlockInfo
        program [] .tokens .length i32 cast.u ## whileIndex
        -1 ## doIndex
      WhileBlockInfo new BlockInfo .whileBlock list.push
    program .openBlocks=
    0 BlockType .WHILE CodeBlock new Token .Block return
  else word "do":s string.eq _if
    program [] .openBlocks list.peek =:: whileBlock?
    whileBlock? .data .whileBlock =:: whileBlock
    program [] .tokens .length i32 cast.u whileBlock .doIndex=
    -1 BlockType .DO CodeBlock new Token .Block return
  else word "finally":s string.eq _if
    "unimplemented" ..panic
  else word "break":s string.eq _if
    "unimplemented" ..panic
  else word "continue":s string.eq _if
    "unimplemented" ..panic
  else word "end":s string.eq _if
    program [] .openBlocks
      list.pop =:: closed
    program .openBlocks=
    ## TODO handle closed block (insert correct jump-distances into operations
    closed switch
      ifBlock case
        closed .ifBlock .elseIndex =:: elseIndex
        elseIndex -1 == if ## no (explicit) else
          closed .ifBlock .ifIndex =:: ifIndex
          program [] .tokens .length i32 cast.u ifIndex -
            program [] .tokens ifIndex @[]
          .Block .target=
          program [] .tokens
            1 BlockType .ELSE CodeBlock new Token .Block list.append
          program .tokens=
        else
          program [] .tokens .length i32 cast.u elseIndex -
            program [] .tokens elseIndex @[]
          .Block .target=
        end
        0 BlockType .IF CodeBlock new Token .EndBlock return
      whileBlock case
        closed .whileBlock .whileIndex =:: whileIndex
        closed .whileBlock .doIndex =:: doIndex
        doIndex -1 == if ## no (explicit) do
          program [] .tokens
            1 BlockType .DO CodeBlock new Token .Block list.append
          program .tokens=
        else
          program [] .tokens .length i32 cast.u doIndex -
            program [] .tokens doIndex @[]
          .Block .target=
        end
        whileIndex program [] .tokens .length i32 cast.u -
          BlockType .WHILE
        CodeBlock new Token .EndBlock return
    end
  end
  ## TODO? resolve identifiers outside procedures at parse time
  program .memory word copyString Token .Identifier
end
## parse a single line returns true if line needs to be continued
proc( string : line Program ptr.mut : program -> bool ) =>: parseLine
  line "exit":s string.eq if
    false program .running=
    false return
  end
  while
    line program [] .parseOffset string.tail program nextToken =:: token =:: consumed
    program [] .parseOffset consumed + program .parseOffset=
    token .EOF ?? !
  do ## TODO make sure to copy strings
    program [] .tokens
      token list.append
    program .tokens=
  end
  program [] .parseOffset iSize cast.u line .length u< or
      program [] .openBlocks .length 0:iSize != if
    true return
  end
  program [] .tokens for printToken end
  ## TODO? type-check before interpreting
  program [] .tokens list.asSlice program evaluateBlock
  false return
end

proc( ProcId : procId Program ptr.mut : program -> ) =>: evaluateCall
  program [] .procedures procId iSize cast.u [] =:: procData
  ## TODO? check arguments
  procData .implementation switch
    code case
      procData .implementation .code program evaluateBlock
      break
    builtIn case
      procData .implementation .builtIn program evaluateBuiltIn
      break
  end
end
proc( Token slice : tokens Program ptr.mut : program -> ) =>: evaluateBlock
  0:i32 =:: mut: ip
  while ip iSize cast.u tokens .length u< do
    tokens ip [] =:: token
    token switch
      Identifier case
        program .identifiers token .Identifier map.get =:: idData?
        idData? optional.isEmpty if
          "Unknown identifier: \"":s io.print
          token .Identifier io.print
          "\"":s io.println
          return
        end
        idData? .data =:: idData
        idData switch
          Variable case
            program [] .stack
              idData .Variable list.append
            program .stack=
            break
          Procedure case
            idData .Procedure program evaluateCall
            break
        end
        break
      Integer case
        program [] .stack
          token .Integer Value .Int Type .NONE TypedValue new list.append
        program .stack=
        break
      Float case "Floats are not supported" ..panic
      Block case
        token .Block .blockType switch
          IF DO case
            program [] .stack
              list.pop =:: cond
            program .stack=
            cond asBool ! if
              ip token .Block .target + ip=
            end
            break
          ELSE case ip token .Block .target + ip= break
          WHILE case break ## nothing to do
        end
        break
      EndBlock case
        ip token .EndBlock .target + ip=
        break
      EOF case return
    end
  finally ip 1 + ip= end
end

5:iSize =:: MAX_ELTS
proc( -> ) =>: main
  ## Program
    4096 mixedArena.create
    128 Procedure list.create
    string.hash@ string.eq@ 1024 Identifier map.create
    128 TypedValue list.create
    128 BlockInfo list.create
    128 Token list.create
    0:i32
    true
  Program new =:: mut: program
  program@ initBuiltIns
  256 sb.create =:: mut: lineBuffer
  while program .running do
    " >> ":s io.print
    lineBuffer readLine lineBuffer=
    0 program@ .parseOffset=
    while
      lineBuffer sb.asStr program@ parseLine
    do
      "... ":s io.print
      lineBuffer '\n' sb.appendC readLine lineBuffer=
    end
    lineBuffer sb.clear lineBuffer=
    program .tokens list.clear program@ .tokens=
    program .stack .length MAX_ELTS u> if
      " ...":s io.print
    end
    program .stack list.asSlice
      $ .length MAX_ELTS u> if
        $ .length MAX_ELTS - slice.tail
      end
    for =:: elt
      ' ' io.print elt printTypedValue
    end
    '\n' io.print
  end
  lineBuffer sb.free ..drop
end
