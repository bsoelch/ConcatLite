import stringIO
import arenaAlloc
import map
import numbers/printNumbers
using std.literals.

enum( NONE BOOL I8 I16 I32 I64 F16 F32 F64 TYPE ) =:: export: Type
union(
  bool : Bool
  i64 : Int
  Type : Type
) =:: export: Value
struct(
  Value : value
  Type : valType
) =:: export: TypedValue
proc( Type : t -> ) =>: export: printType
  t switch
    NONE case "?":s break
    BOOL case "bool":s break
    I8 case "i8":s break
    I16 case "i16":s break
    I32 case "i32":s break
    I64 case "i64":s break
    F16 case "f16":s break
    F32 case "f32":s break
    F64 case "f64":s break
    TYPE case "type":s break
  end io.print
end
proc( Value : val -> ) =>: export: printValue
  val switch
    Int case val .Int io.print break
    Bool case val .Bool if "true":s else "false":s end io.print break
    Type case val .Type printType break
  end
end
proc( TypedValue : val -> ) =>: export: printTypedValue
  val .valType printType
  ": ":s io.print
  val .value printValue
end
proc( TypedValue : val -> bool ) =>: export: asBool
  val .valType .BOOL ?? ! and val .valType .NONE ?? ! if
    "error handling" ..panic
  end
  val .value .Bool ?? ! if
    "error handling" ..panic
  end
  val .value .Bool
end
proc( TypedValue : val -> i32 ) =>: export: asI32
  val .valType .I32 ?? ! and val .valType .NONE ?? ! if
    "error handling" ..panic
  end
  val .value .Int ?? ! if
    "error handling" ..panic
  end
  val .value .Int i32 cast
end

enum( IF ELSE WHILE DO  PROCEDURE TUPLE_TYPE PROC_TYPE TO_TYPE ) =:: export: BlockType
struct(
  i32 : target
  BlockType : blockType
) =:: export: CodeBlock
proc( CodeBlock : block -> ) =>: export: printBlock
  block .blockType switch
    IF    case "if -> ":s    io.print break
    ELSE  case "else -> ":s  io.print break
    WHILE case "while -> ":s io.print break
    DO    case "do -> ":s    io.print break
    PROCEDURE  case "procedure: ":s    io.print break
    PROC_TYPE  case "proc-type: ":s    io.print break
    TUPLE_TYPE case "tuple-type: ":s   io.print break
    TO_TYPE    case "to-type: ":s      io.print break
  end
  block .target io.println
end
i16 =:: export: IdModifier
namespace: IdModifier
  0:IdModifier =:: export: NONE
  1:IdModifier =:: export: MUTABLE
  2:IdModifier =:: export: BUILTIN
  ( IdModifier IdModifier -> IdModifier ) : alias: export: or i16.or
  ( IdModifier IdModifier -> IdModifier ) : alias: export: and i16.and
  ( IdModifier -> bool ) : alias: export: toBool i16.toBool
end
overload: & IdModifier.and end
overload: | IdModifier.or end
overload: ? IdModifier.toBool end
struct( string : name IdModifier : modifiers ) =:: export: InitInfo
union(
  string : Identifier
  string : SetValue
  InitInfo : Declare
  InitInfo : TypedInitialize
  InitInfo : Initialize
  i64 : Integer
  f64 : Float
  CodeBlock : Block
  CodeBlock : EndBlock
  _ : EOF
) =:: export: Token
proc( Token : token -> ) =>: export: printToken
  "* ":s io.print
  token switch
    Identifier case
      "Identifier: \"":s io.print
      token .Identifier io.print
      "\"":s io.println
      break
    SetValue case
      "SetValue: \"":s io.print
      token .SetValue io.print
      "\"":s io.println
      break
    Declare case ## TODO? print modifiers
      "Declare: \"":s io.print
      token .Declare .name io.print
      "\"":s io.println
      break
    Initialize case
      "Initialize: \"":s io.print
      token .Initialize .name io.print
      "\"":s io.println
      break
    TypedInitialize case
      "TypedInitialize: \"":s io.print
      token .TypedInitialize .name io.print
      "\"":s io.println
      break
    Integer case
      "Int: ":s io.print token .Integer io.println
      break
    Float case
      "Float: ":s io.print token .Float io.println
      break
    Block case
      "Block: ":s io.print token .Block printBlock
      break
    EndBlock case
      "EndBlock: ":s io.print token .EndBlock printBlock
      break
    EOF case
      "EOF":s io.println
      break
  end
end
type : export: BuiltIn
union(
  Token slice : code
  BuiltIn : builtIn
) =:: export: ProcImplementation
struct(
  Type slice : arguments
  ProcImplementation : implementation
) =:: export: Procedure
struct(
  TypedValue : value
  IdModifier : modifiers
) =:: export: IdData
union(
  Procedure ptr : Procedure
  IdData : Variable
) =:: export: Identifier

struct(
  i32 : ifIndex
  i32 : elseIndex
  bool : autoClose
) =:: export: IfBlockInfo
struct(
  i32 : whileIndex
  i32 : doIndex
  ## TODO support break/continue
) =:: export: WhileBlockInfo
enum( NONE PROC TUPLE ) =:: export: CompositeType
struct(
  i32 : blockStart
  i32 : toIndex
  CompositeType : compType
) =:: export: CompositeBlockInfo
struct(
  string : procName
  i32 : blockStart
  IdModifier : idModifiers
) =:: export: ProcedureBlockInfo
union(
  IfBlockInfo : ifBlock
  WhileBlockInfo : whileBlock
  CompositeBlockInfo : compositeBlock
  ProcedureBlockInfo : procedureBlock
) =:: export: BlockInfo
struct(
  MixedArenaAllocator : memory
  string Identifier hashMap : identifiers
  TypedValue list : stack
  iSize : stackOffset
  ## parser state
  BlockInfo list : openBlocks
  Token list : tokens
  i32 : parseOffset
  bool : running
) =:: export: Program
proc( iSize : argCount Program ptr : program -> bool ) =>: export: checkStack
  argCount program .stack [] .length program [] .stackOffset - u>
end
proc( iSize : argCount Program ptr.mut : program -> iSize ) =>: export: offsetStack
  program [] .stackOffset =:: oldOffset
    argCount program .stack [] .length u<= "enough stack capacity" assert
    program .stack [] .length argCount - program .stackOffset=
  oldOffset
end
proc( iSize : oldOffset Program ptr.mut : program -> ) =>: export: resetStack
  oldOffset program .stack [] .length u<= "enough stack capacity" assert
  oldOffset program .stackOffset=
end
