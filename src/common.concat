import stringIO
import arenaAlloc
import map
import numbers/printNumbers
import future/rcSlice
using std.literals.

## TODO split into multiple files (types,constants,identifiers)
i16 =:: export: IdModifier
namespace: IdModifier
  0:IdModifier =:: export: NONE
  1:IdModifier =:: export: MUTABLE
  2:IdModifier =:: export: BUILTIN
  4:IdModifier =:: export: EXPORT
  8:IdModifier =:: export: GLOBAL
  ( IdModifier IdModifier -> IdModifier ) : alias: export: or i16.or
  ( IdModifier IdModifier -> IdModifier ) : alias: export: and i16.and
  ( IdModifier -> bool ) : alias: export: toBool i16.toBool
end
overload: & IdModifier.and end
overload: | IdModifier.or end
overload: ? IdModifier.toBool end
struct(
  string : name
  IdModifier : idModifiers
) =:: export: Label
union( _ : None Label : Label ) =:: export: ElementLabel
type : export: Type
struct(
  Type slice : elements
  ## TODO? use `Label _ ptr optional` to avoid storing length twice
  ElementLabel slice : labels
) =:: export: CompositeType
struct(
  CompositeType : inTypes
  CompositeType : outTypes
) =:: export: ProcedureType
union(
  i64 : Fixed
  _ : Unbounded
) =:: export: ArraySize
struct(
  Type : baseType
  ArraySize : size
) =:: export: ArrayType
union(
  _ : None
  _ : Bool
  _ : Char8
  _ : I8
  _ : I16
  _ : I32
  _ : I64
  _ : F16
  _ : F32
  _ : F64
  _ : Type
  CompositeType ptr : Tuple
  CompositeType ptr : Union
  ProcedureType ptr : Procedure
  ArrayType ptr : Array
  ArrayType ptr : Pointer
  ArrayType ptr : MutablePointer
) =:: export: Type
type : export: Procedure
type : export: Value
struct(
  char8 _ ptr : data
  i32 : length
) =:: export: StringLiteral
proc( StringLiteral : lit -> string ) =>: export: asString
  lit .data lit .length string.create
end
union(
  bool : Bool
  i64 : Int
  f64 : Float
  Type : Type
  Procedure ptr : Procedure
  Value rcSlice : Composite ## TODO remember element labels
  StringLiteral : String
) =:: export: Value
struct(
  Value : value
  Type : valType
) =:: export: TypedValue
proc( TypedValue -> TypedValue ) =>: export: useTypedValue
  $ .value useValue >$ .value=
end
proc( Value : val -> Value ) =>: export: useValue
  val .Composite ?? ! if val return end
  val .Composite [] .length for =:: i
    val .Composite i rcSlice.get
      useValue
    val .Composite i rcSlice.set
  end
  val .Composite rcSlice.use Value .Composite
end
proc( Value : val -> ) =>: export: freeValue
  val .Composite ?? ! if return end
  val .Composite [] .length for =:: i
    val .Composite i rcSlice.get freeValue
  end
  val .Composite rcSlice.free
end
proc( Value : val iSize : skipIndex -> Value ) =>: export: cloneValue
  val .Composite ?? if
    val .Composite [] .length Value rcSlice.create =:: newValue
    val .Composite [] .length for =:: i
      i skipIndex == if continue end
      val .Composite
        i iSize cast.u rcSlice.get useValue
      newValue i iSize cast.u rcSlice.set
    end
    newValue Value .Composite return
  end
  val .String ?? if
    val .String .length iSize cast.u Value rcSlice.create =:: newValue
    val .String .length iSize cast.u for =:: i
      i skipIndex == if continue end
      val .String .data
        i [] i64 cast.u Value .Int
      newValue i iSize cast.u rcSlice.set
    end
    newValue Value .Composite return
  end
  ## TODO? cloning a string to a mutable array
  val return
end
proc( Type : tp -> Value ) =>: export: defaultValue
  tp switch
    ## TODO? map none-type to special wildcard value
    None Bool case false Value .Bool return
    Char8 I8 I16 I32 I64 case 0 Value .Int return
    F16 F32 F64 case 0.0 Value .Float return
    Type case Type .None Value .Type return
    Tuple case
      tp .Tuple .elements [] .length iSize cast.u =:: size
      size Value rcSlice.create =:: tupleData
      size for =:: i
        tp .Tuple [] .elements i [] defaultValue tupleData i rcSlice.set
      end
      tupleData Value .Composite return
    Array case
      tp .Array .size [] .Fixed ?? ! if
        "error handling" ..panic
      end
      ## TODO? add special case handling for arrays of primitive types
      tp .Array [] .baseType defaultValue =:: eltValue
      tp .Array .size [] .Fixed iSize cast.u =:: size
      size Value rcSlice.create =:: arrayData
      size for =:: i
        eltValue useValue arrayData i rcSlice.set
      end
      eltValue freeValue ## ref-count is one too high
      arrayData Value .Composite return
    Union case "unimplemented: union values" ..panic
    Procedure case "unimplemented: default procedure" ..panic ## ? default procedure that crashes program when called
    Pointer MutablePointer case "unimplemented: pointer values" ..panic
  end
end
proc( StringLiteral -> ) =>: printStringLiteral
  asString string.chars for =:: c
    c '\x20' < or c '\x7f' >= if ## non-printable ASCII-characters + hex-codes for multi-char characters
      c i32 cast.u =:: charId
      c switch
        '\n' case "\\n":s io.print continue
        '\t' case "\\t":s io.print continue
        '\r' case "\\r":s io.print continue
        default
          "\\x":s io.print
          charId 0xff &
            $ 0x10 < if '0' io.printC end
          io.printX
          continue
      end
    end
    c '\\' == c '\'' == | c '\"' == | if
      '\\' io.printC
    end
    c io.printC
  end
end
proc( ArraySize : size -> ) =>: printArraySize
  size switch
    Fixed case size .Fixed io.print return
    Unbounded case '_' io.printC return
  end
end
proc( CompositeType : t -> ) =>: export: printComposite
  t .elements .length for =:: i
    t .elements i [] printType
    i t .labels .length u< and t .labels i [] =:: label label .Label ?? if
      " : ":s io.print
      ## TODO? print modifiers
      label .Label .name io.print
    end
   ' ' io.print
  end
end
proc( Type : t -> ) =>: export: printType
  t switch
    None case "?":s io.print break
    Bool case "bool":s io.print break
    Char8 case "char8":s io.print break
    I8 case "i8":s io.print break
    I16 case "i16":s io.print break
    I32 case "i32":s io.print break
    I64 case "i64":s io.print break
    F16 case "f16":s io.print break
    F32 case "f32":s io.print break
    F64 case "f64":s io.print break
    Type case "type":s io.print break
    Tuple case
      "( ":s io.print
        t .Tuple [] printComposite
      ')' io.print break
    Union case
      "union( ":s io.print
        t .Union [] printComposite
      ')' io.print break
    Procedure case
      "( ":s io.print
        t .Procedure .inTypes [] printComposite
        "-> ":s io.print
        t .Procedure .outTypes [] printComposite
      ')' io.print break
    Array case
      t .Array [] .baseType printType ' ' io.print
        t .Array [] .size printArraySize ' ' io.print
      "array":s io.print
       break
    Pointer case
      t .Pointer [] .baseType printType ' ' io.print
        t .Pointer [] .size printArraySize ' ' io.print
      "ptr":s io.print
       break
    MutablePointer case
      t .MutablePointer [] .baseType printType ' ' io.print
        t .MutablePointer [] .size printArraySize ' ' io.print
      "ptr.mut":s io.print
       break
  end
end
proc( Value : val -> ) =>: export: printValue
  val switch
    Int case val .Int io.print break
    Float case val .Float io.print break
    Bool case val .Bool if "true":s else "false":s end io.print break
    Type case val .Type printType break
    Procedure case "procedure@":s io.print val .Procedure iPtr cast! i64 cast.u io.print break
    Composite case
      '{' io.printC
      val .Composite [] .length for =:: i
        ' ' io.printC val .Composite i rcSlice.get printValue
      end " }":s io.print
      break
    String case
      '"' io.printC val .String printStringLiteral '"' io.printC break
  end
end
proc( TypedValue : val -> ) =>: export: printTypedValue
  val .valType printType
  ": ":s io.print
  val .value printValue
end
proc( TypedValue : val -> bool ) =>: export: asBool
  val .valType .Bool ?? ! and val .valType .None ?? ! if
    "error handling" ..panic
  end
  val .value .Bool ?? ! if
    "error handling" ..panic
  end
  val .value .Bool
end
proc( TypedValue : val -> Type ) =>: export: asType
  val .valType .Type ?? ! and val .valType .None ?? ! if
    "error handling" ..panic
  end
  val .value .Type ?? ! if
    "error handling" ..panic
  end
  val .value .Type
end
proc( TypedValue : val -> i32 ) =>: export: asI32
  val .valType .I32 ?? ! and val .valType .None ?? ! if
    "error handling" ..panic
  end
  val asInt i32 cast
end
proc( TypedValue : val -> i64 ) =>: export: asInt
  val .value .Int ?? ! if
    "error handling" ..panic
  end
  val .value .Int
end

proc( CompositeType ptr : t string : name -> iSize optional ) =>: compositeTypeElementIndex
  t [] .labels .length for =:: i
    t [] .labels i [] =:: label
    label .Label ?? and label .Label .name name string.eq if i optional.wrap return end
  end
  iSize optional.empty
end
proc( Value : v string : name -> iSize optional ) =>: getValueElementIndex
  ## TODO support labeled values
  iSize optional.empty return
end
proc( TypedValue : val string : name -> iSize optional ) =>: export: getElementIndex
  val .valType .Tuple ?? if
    val .valType .Tuple name compositeTypeElementIndex
  else val .valType .Union ?? _if
    val .valType .Union name compositeTypeElementIndex
  else val .valType .None ?? _if
    val .value name getValueElementIndex
  else
    ## TODO are there any other types with named elements
    iSize optional.empty return
  end
end

enum( IF ELSE WHILE DO  PROCEDURE TUPLE_TYPE UNION_TYPE PROC_TYPE TO_TYPE INITIALIZER ) =:: export: BlockType
struct(
  i32 : target
  BlockType : blockType
) =:: export: CodeBlock
proc( CodeBlock : block -> ) =>: export: printBlock
  block .blockType switch
    IF    case "if -> ":s    io.print break
    ELSE  case "else -> ":s  io.print break
    WHILE case "while -> ":s io.print break
    DO    case "do -> ":s    io.print break
    PROCEDURE  case "procedure: ":s    io.print break
    PROC_TYPE  case "proc-type: ":s    io.print break
    TUPLE_TYPE case "tuple-type: ":s   io.print break
    UNION_TYPE case "union-type: ":s   io.print break
    TO_TYPE    case "to-type: ":s      io.print break
    INITIALIZER case "initializer: ":s io.print break
  end
  block .target io.println
end

i32 =:: export: FileId
namespace: FileId
  -1:FileId =:: export: GLOBAL
end
i32 =:: export: ScopeId
namespace: ScopeId
 -1:ScopeId =:: export: GLOBAL
end
struct(
  string : name
  FileId : fileId
  ScopeId : scopeId
) =:: export: IdName
namespace: IdName
  proc( IdName : a IdName : b -> bool ) =>: export: eq
    a .fileId b .fileId == and a .scopeId b .scopeId == and a .name b .name string.eq end
  end
  proc( IdName : a -> i32 ) =>: export: hash
    a .fileId i32 cast.u 31 * a .scopeId i32 cast.u + 31 * a .name string.hash +
  end
end
enum( DECLARE TYPED AUTO ) =:: export: InitType
struct( string : name IdModifier : modifiers InitType : initType ) =:: export: InitInfo
union(
  i32 : Copy ## copy the k-th element from the top (0 indexed)
  i32 : Drop ## drop the top k-th elements
  i32 : Rotate ## rotate the k-th element to the top (0 indexed), if negative do the reverse rotation
) =:: export: StackOp
enum( ARRAY POINTER MUTABLE_POINTER ) =:: export: ArrayKind
enum( GET SET AT ) =:: export: ArrayOperator
union(
  string : ImportLocal
  string : ImportLib
  string : Identifier
  string : SetValue
  i64 : GetElement
  i64 : SetElement
  string : GetNamedElement
  string : SetNamedElement
  InitInfo : Initialize
  TypedValue : Constant
  CodeBlock : Block
  CodeBlock : EndBlock
  StackOp : StackOp
  _ : New
  ArrayKind : NewArrayType
  ArrayOperator : ArrayOperator
  string : BeginNamespace
  string : EndNamespace
  _ : EOF
) =:: export: Token
proc( Token : token -> ) =>: export: printToken
  "* ":s io.print
  token switch
    Identifier case
      "Identifier: \"":s io.print
      token .Identifier io.print
      "\"":s io.println
      break
    SetValue case
      "SetValue: \"":s io.print
      token .SetValue io.print
      "\"":s io.println
      break
    GetElement case
      "GetElement: ":s io.print token .GetElement io.println
      break
    SetElement case
      "SetElement: ":s io.print token .SetElement io.println
      break
    GetNamedElement case
      "GetNamedElement: ":s io.print token .GetNamedElement io.println
      break
    SetNamedElement case
      "SetNamedElement: ":s io.print token .SetNamedElement io.println
      break
    ImportLocal case
      "ImportLocal: ":s io.print token .ImportLocal io.println
      break
    ImportLib case
      "ImportLib: ":s io.print token .ImportLib io.println
      break
    Initialize case
      token .Initialize .initType switch
        DECLARE case "Declare: \"":s io.print break
        AUTO case "Initialize: \"":s io.print break
        TYPED case "Typed Initialize: \"":s io.print break
      end
      token .Initialize .name io.print
      "\"":s io.println
      break
    Constant case
      "Constant: ":s io.print token .Constant printTypedValue '\n' io.printC
      break
    Block case
      "Block: ":s io.print token .Block printBlock
      break
    EndBlock case
      "EndBlock: ":s io.print token .EndBlock printBlock
      break
    StackOp case
      token .StackOp switch
        Copy case "Copy: ":s io.print token .StackOp .Copy break
        Rotate case "Rotate: ":s io.print token .StackOp .Rotate break
        Drop case "Drop: ":s io.print token .StackOp .Drop break
      end io.println
      break
    New case "New":s io.println break
    NewArrayType case
      token .NewArrayType switch
        ARRAY case "array":s io.println break
        POINTER case "ptr":s io.println break
        MUTABLE_POINTER case "ptr.mut":s io.println break
      end
      break
    ArrayOperator case
      token .ArrayOperator switch
        GET case "[]":s io.println break
        SET case "=[]":s io.println break
        AT case "@[]":s io.println break
      end
      break
    BeginNamespace case
      "Namespace: \"":s io.print
      token .BeginNamespace io.print
      "\"":s io.println
      break
    EndNamespace case
      "End namespace: \"":s io.print
      token .EndNamespace io.print
      "\"":s io.println
      break
    EOF case "EOF":s io.println break
  end
end
type : export: BuiltIn
struct(
  Token slice : code
  char8 slice.mut : namespace
  ScopeId slice : scopeStack
  ScopeId : scope
  FileId : file
) =:: export: ProcCode
union(
  ProcCode : code
  BuiltIn : builtIn
) =:: export: ProcImplementation
struct(
  ProcedureType ptr : procType
  ProcImplementation : implementation
) =:: export: Procedure
struct(
  TypedValue : value
  IdModifier : modifiers
) =:: export: Identifier

struct(
  i32 : ifIndex
  i32 : elseIndex
  bool : autoClose
) =:: export: IfBlockInfo
struct(
  i32 : whileIndex
  i32 : doIndex
  ## TODO support break/continue
) =:: export: WhileBlockInfo
enum( NONE PROC TUPLE UNION INITIALIZER ) =:: export: CompositeBlockType
struct(
  i32 : blockStart
  i32 : toIndex
  CompositeBlockType : compType
) =:: export: CompositeBlockInfo
struct(
  string : procName
  i32 : blockStart
  IdModifier : idModifiers
) =:: export: ProcedureBlockInfo
union(
  IfBlockInfo : ifBlock
  WhileBlockInfo : whileBlock
  CompositeBlockInfo : compositeBlock
  ProcedureBlockInfo : procedureBlock
  string : namespace
) =:: export: BlockInfo
enum( STOPPED RUN TYPE_BLOCK INITIALIZER ) =:: export: InterpreterMode
struct(
  MixedArenaAllocator : memory
  IdName Identifier hashMap : identifiers
  TypedValue list : stack
  iSize : stackOffset
  ElementLabel list : nameStack
  iSize : nameStackOffset
  string list : imports
  ScopeId list : scopeStack
  FileId : currentFile
  ScopeId : currentScope
  ScopeId : scopeCounter
  ## parser state
  BlockInfo list : openBlocks
  stringBuilder : currentNamespace
  stringBuilder : nameBuffer
  Token list : tokens
  i32 : parseOffset
  InterpreterMode : mode
) =:: export: Program
proc( Type : base ArraySize : size Program ptr.mut : program -> ArrayType ptr ) =>: export: newArrayType
  program [] .memory
    ## ArrayType
      base
      size
    ArrayType new mixedArena.copyValue =:: arrayBody
  program .memory=
  arrayBody
end
proc( Program ptr : program -> iSize ) =>: export: stackSize
  program .stack [] .length program [] .stackOffset u>= "valid stack offset" assert
  program .stack [] .length program [] .stackOffset -
end
proc( Program ptr : program -> iSize ) =>: export: nameStackSize
  program .nameStack [] .length program [] .nameStackOffset u>= "valid name-stack offset" assert
  program .nameStack [] .length program [] .nameStackOffset -
end
proc( iSize : argCount Program ptr : program -> bool ) =>: export: checkStack
  program nameStackSize =:: nameStackLength
  program stackSize =:: stackLength
  nameStackLength stackLength u<= "nameStack .length <= stack .length" assert
  argCount stackLength nameStackLength - u>
end
proc( iSize : argCount Program ptr.mut : program -> iSize iSize ) =>: export: offsetStack
  argCount program checkStack if "stack underflow" ..panic end
  program [] .stackOffset =:: oldOffset
    program .stack [] .length argCount - program .stackOffset=
  oldOffset
  program [] .nameStackOffset =:: oldNameOffset
    program .nameStack [] .length program .nameStackOffset=
  oldNameOffset
end
proc( iSize : oldOffset iSize : oldNameOffset Program ptr.mut : program -> ) =>: export: resetStack
  oldOffset program .stack [] .length u<= "enough stack capacity" assert
  oldNameOffset program .nameStack [] .length u<= "enough stack capacity" assert
  oldOffset program .stackOffset=
  oldNameOffset program .nameStackOffset=
end
