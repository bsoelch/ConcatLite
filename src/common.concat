import stringIO
import arenaAlloc
import map
import numbers/printNumbers
import future/rcSlice
using std.literals.

type : export: Type
struct(
  Type slice : elements
  ## TODO? remember element names (? list of pointers to "Label" structs )
) =:: export: CompositeType
struct(
  CompositeType : inTypes
  CompositeType : outTypes
) =:: export: ProcedureType
union(
  i64 : Fixed
  _ : Unbounded
) =:: export: ArraySize
struct(
  Type : baseType
  ArraySize : size
) =:: export: ArrayType
union(
  _ : None
  _ : Bool
  _ : Char8
  _ : I8
  _ : I16
  _ : I32
  _ : I64
  _ : F16
  _ : F32
  _ : F64
  _ : Type
  CompositeType ptr : Tuple
  CompositeType ptr : Union
  ProcedureType ptr : Procedure
  ArrayType ptr : Array
  ArrayType ptr : Pointer
  ArrayType ptr : MutablePointer
) =:: export: Type
type : export: Procedure
type : export: Value
struct(
  char8 _ ptr : data
  i32 : length
) =:: export: StringLiteral
proc( StringLiteral : lit -> string ) =>: export: asString
  lit .data lit .length string.create
end
union(
  bool : Bool
  i64 : Int
  f64 : Float
  Type : Type
  Procedure ptr : Procedure
  Value rcSlice : Composite
  StringLiteral : String
) =:: export: Value
struct(
  Value : value
  Type : valType
) =:: export: TypedValue
proc( TypedValue -> TypedValue ) =>: export: useTypedValue
  $ .value useValue >$ .value=
end
proc( Value : val -> Value ) =>: export: useValue
  val .Composite ?? ! if val return end
  val .Composite [] .length for =:: i
    val .Composite i rcSlice.get
      useValue
    val .Composite i rcSlice.set
  end
  val .Composite rcSlice.use Value .Composite
end
proc( Value : val -> ) =>: export: freeValue
  val .Composite ?? ! if return end
  val .Composite [] .length for =:: i
    val .Composite i rcSlice.get freeValue
  end
  val .Composite rcSlice.free
end
proc( Type : tp -> Value ) =>: export: defaultValue
  tp switch
    ## TODO? map none-type to special wildcard value
    None Bool case false Value .Bool return
    Char8 I8 I16 I32 I64 case 0 Value .Int return
    F16 F32 F64 case 0.0 Value .Float return
    Type case Type .None Value .Type return
    Tuple case
      tp .Tuple .elements [] .length iSize cast.u =:: size
      size Value rcSlice.create =:: tupleData
      size for =:: i
        tp .Tuple [] .elements i [] defaultValue tupleData i rcSlice.set
      end
      tupleData Value .Composite return
    Array case
      tp .Array .size [] .Fixed ?? ! if
        "error handling" ..panic
      end
      ## TODO? add special case handling for arrays of primitive types
      tp .Array [] .baseType defaultValue =:: eltValue
      tp .Array .size [] .Fixed iSize cast.u =:: size
      size Value rcSlice.create =:: arrayData
      size for =:: i
        eltValue useValue arrayData i rcSlice.set
      end
      eltValue freeValue ## ref-count is one too high
      arrayData Value .Composite return
    Union case "unimplemented: union values" ..panic
    Procedure case "unimplemented: default procedure" ..panic ## ? default procedure that crashes program when called
    Pointer MutablePointer case "unimplemented: pointer values" ..panic
  end
end
proc( StringLiteral -> ) =>: printStringLiteral
  asString string.chars for =:: c
    c '\x20' < or c '\x7f' >= if ## non-printable ASCII-characters + hex-codes for multi-char characters
      c i32 cast.u =:: charId
      c switch
        '\n' case "\\n":s io.print continue
        '\t' case "\\t":s io.print continue
        '\r' case "\\r":s io.print continue
        default
          "\\x":s io.print
          charId 0xff &
            $ 0x10 < if '0' io.printC end
          io.printX
          continue
      end
    end
    c '\\' == c '\'' == | c '\"' == | if
      '\\' io.printC
    end
    c io.printC
  end
end
proc( ArraySize : size -> ) =>: printArraySize
  size switch
    Fixed case size .Fixed io.print return
    Unbounded case '_' io.printC return
  end
end
proc( Type : t -> ) =>: export: printType
  t switch
    None case "?":s io.print break
    Bool case "bool":s io.print break
    Char8 case "char8":s io.print break
    I8 case "i8":s io.print break
    I16 case "i16":s io.print break
    I32 case "i32":s io.print break
    I64 case "i64":s io.print break
    F16 case "f16":s io.print break
    F32 case "f32":s io.print break
    F64 case "f64":s io.print break
    Type case "type":s io.print break
    Tuple case
      "( ":s io.print
        t .Tuple [] .elements for printType ' ' io.print end
      ')' io.print break
    Union case
      "union( ":s io.print
        t .Union [] .elements for printType ' ' io.print end
      ')' io.print break
    Procedure case
      "( ":s io.print
        t .Procedure .inTypes [] .elements for printType ' ' io.print end
        "-> ":s io.print
        t .Procedure .outTypes [] .elements for printType ' ' io.print end
      ')' io.print break
    Array case
      t .Array [] .baseType printType ' ' io.print
        t .Array [] .size printArraySize ' ' io.print
      "array":s io.print
       break
    Pointer case
      t .Pointer [] .baseType printType ' ' io.print
        t .Pointer [] .size printArraySize ' ' io.print
      "ptr":s io.print
       break
    MutablePointer case
      t .MutablePointer [] .baseType printType ' ' io.print
        t .MutablePointer [] .size printArraySize ' ' io.print
      "ptr.mut":s io.print
       break
  end
end
proc( Value : val -> ) =>: export: printValue
  val switch
    Int case val .Int io.print break
    Float case val .Float io.print break
    Bool case val .Bool if "true":s else "false":s end io.print break
    Type case val .Type printType break
    Procedure case "procedure@":s io.print val .Procedure iPtr cast! i64 cast.u io.print break
    Composite case
      '{' io.printC
      val .Composite [] .length for =:: i
        ' ' io.printC val .Composite i rcSlice.get printValue
      end " }":s io.print
      break
    String case
      '"' io.printC val .String printStringLiteral '"' io.printC break
  end
end
proc( TypedValue : val -> ) =>: export: printTypedValue
  val .valType printType
  ": ":s io.print
  val .value printValue
end
proc( TypedValue : val -> bool ) =>: export: asBool
  val .valType .Bool ?? ! and val .valType .None ?? ! if
    "error handling" ..panic
  end
  val .value .Bool ?? ! if
    "error handling" ..panic
  end
  val .value .Bool
end
proc( TypedValue : val -> Type ) =>: export: asType
  val .valType .Type ?? ! and val .valType .None ?? ! if
    "error handling" ..panic
  end
  val .value .Type ?? ! if
    "error handling" ..panic
  end
  val .value .Type
end
proc( TypedValue : val -> i32 ) =>: export: asI32
  val .valType .I32 ?? ! and val .valType .None ?? ! if
    "error handling" ..panic
  end
  val .value .Int ?? ! if
    "error handling" ..panic
  end
  val .value .Int i32 cast
end

enum( IF ELSE WHILE DO  PROCEDURE TUPLE_TYPE PROC_TYPE TO_TYPE INITIALIZER ) =:: export: BlockType
struct(
  i32 : target
  BlockType : blockType
) =:: export: CodeBlock
proc( CodeBlock : block -> ) =>: export: printBlock
  block .blockType switch
    IF    case "if -> ":s    io.print break
    ELSE  case "else -> ":s  io.print break
    WHILE case "while -> ":s io.print break
    DO    case "do -> ":s    io.print break
    PROCEDURE  case "procedure: ":s    io.print break
    PROC_TYPE  case "proc-type: ":s    io.print break
    TUPLE_TYPE case "tuple-type: ":s   io.print break
    TO_TYPE    case "to-type: ":s      io.print break
    INITIALIZER case "initializer: ":s io.print break
  end
  block .target io.println
end
i16 =:: export: IdModifier
namespace: IdModifier
  0:IdModifier =:: export: NONE
  1:IdModifier =:: export: MUTABLE
  2:IdModifier =:: export: BUILTIN
  ( IdModifier IdModifier -> IdModifier ) : alias: export: or i16.or
  ( IdModifier IdModifier -> IdModifier ) : alias: export: and i16.and
  ( IdModifier -> bool ) : alias: export: toBool i16.toBool
end
overload: & IdModifier.and end
overload: | IdModifier.or end
overload: ? IdModifier.toBool end

enum( DECLARE TYPED AUTO ) =:: export: InitType
struct( string : name IdModifier : modifiers InitType : initType ) =:: export: InitInfo
union(
  i32 : Copy ## copy the k-th element from the top (0 indexed)
  i32 : Drop ## drop the top k-th elements
  i32 : Rotate ## rotate the k-th element to the top (0 indexed), if negative do the reverse rotation
) =:: export: StackOp
union(
  string : Identifier
  string : SetValue
  i64 : GetElement
  i64 : SetElement
  InitInfo : Initialize
  TypedValue : Constant
  CodeBlock : Block
  CodeBlock : EndBlock
  StackOp : StackOp
  _ : New
  _ : EOF
) =:: export: Token
proc( Token : token -> ) =>: export: printToken
  "* ":s io.print
  token switch
    Identifier case
      "Identifier: \"":s io.print
      token .Identifier io.print
      "\"":s io.println
      break
    SetValue case
      "SetValue: \"":s io.print
      token .SetValue io.print
      "\"":s io.println
      break
    GetElement case
      "GetElement: ":s io.print token .GetElement io.println
      break
    SetElement case
      "SetElement: ":s io.print token .SetElement io.println
      break
    Initialize case
      token .Initialize .initType switch
        DECLARE case "Declare: \"":s io.print break
        AUTO case "Initialize: \"":s io.print break
        TYPED case "Typed Initialize: \"":s io.print break
      end
      token .Initialize .name io.print
      "\"":s io.println
      break
    Constant case
      "Constant: ":s io.print token .Constant printTypedValue '\n' io.printC
      break
    Block case
      "Block: ":s io.print token .Block printBlock
      break
    EndBlock case
      "EndBlock: ":s io.print token .EndBlock printBlock
      break
    StackOp case
      token .StackOp switch
        Copy case "Copy: ":s io.print token .StackOp .Copy break
        Rotate case "Rotate: ":s io.print token .StackOp .Rotate break
        Drop case "Drop: ":s io.print token .StackOp .Drop break
      end io.println
      break
    New case "New":s io.println break
    EOF case "EOF":s io.println break
  end
end
type : export: BuiltIn
union(
  Token slice : code
  BuiltIn : builtIn
) =:: export: ProcImplementation
struct(
  ProcedureType ptr : procType
  ProcImplementation : implementation
) =:: export: Procedure
struct(
  TypedValue : value
  IdModifier : modifiers
) =:: export: Identifier

struct(
  i32 : ifIndex
  i32 : elseIndex
  bool : autoClose
) =:: export: IfBlockInfo
struct(
  i32 : whileIndex
  i32 : doIndex
  ## TODO support break/continue
) =:: export: WhileBlockInfo
enum( NONE PROC TUPLE INITIALIZER ) =:: export: CompositeBlockType
struct(
  i32 : blockStart
  i32 : toIndex
  CompositeBlockType : compType
) =:: export: CompositeBlockInfo
struct(
  string : procName
  i32 : blockStart
  IdModifier : idModifiers
) =:: export: ProcedureBlockInfo
union(
  IfBlockInfo : ifBlock
  WhileBlockInfo : whileBlock
  CompositeBlockInfo : compositeBlock
  ProcedureBlockInfo : procedureBlock
) =:: export: BlockInfo
## "interpreter mode" ( set-reset functionality )
##  code
##  type-block
##  initializer
##  enum
##  switch-label?
struct(
  MixedArenaAllocator : memory
  string Identifier hashMap : identifiers
  TypedValue list : stack
  iSize : stackOffset
  ## parser state
  BlockInfo list : openBlocks
  Token list : tokens
  i32 : parseOffset
  bool : running
) =:: export: Program
proc( Type : base i64 : size Program ptr.mut : program -> ArrayType ptr ) =>: export: newArrayType
  program [] .memory
    ## ArrayType
      base
      size ArraySize .Fixed
    ArrayType new mixedArena.copyValue =:: arrayBody
  program .memory=
  arrayBody
end
proc( iSize : argCount Program ptr : program -> bool ) =>: export: checkStack
  argCount program .stack [] .length program [] .stackOffset - u>
end
proc( iSize : argCount Program ptr.mut : program -> iSize ) =>: export: offsetStack
  program [] .stackOffset =:: oldOffset
    argCount program .stack [] .length u<= "enough stack capacity" assert
    program .stack [] .length argCount - program .stackOffset=
  oldOffset
end
proc( iSize : oldOffset Program ptr.mut : program -> ) =>: export: resetStack
  oldOffset program .stack [] .length u<= "enough stack capacity" assert
  oldOffset program .stackOffset=
end
