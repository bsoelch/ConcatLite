import stringIO
import arenaAlloc
import map
import numbers/printNumbers
using std.literals.

type : export: Type
struct(
  Type slice : elements
  ## TODO? remember element names (? list of pointers to "Label" structs )
) =:: export: CompositeType
struct(
  CompositeType : inTypes
  CompositeType : outTypes
) =:: export: ProcedureType
union(
  _ : None
  _ : Bool
  _ : I8
  _ : I16
  _ : I32
  _ : I64
  _ : F16
  _ : F32
  _ : F64
  _ : Type
  CompositeType ptr : Tuple
  CompositeType ptr : Union
  ProcedureType ptr : Procedure
) =:: export: Type
type : export: Procedure
union(
  bool : Bool
  i64 : Int
  f64 : Float
  Type : Type
  Procedure ptr : Procedure
) =:: export: Value
struct(
  Value : value
  Type : valType
) =:: export: TypedValue
proc( Type : t -> ) =>: export: printType
  t switch
    None case "?":s io.print break
    Bool case "bool":s io.print break
    I8 case "i8":s io.print break
    I16 case "i16":s io.print break
    I32 case "i32":s io.print break
    I64 case "i64":s io.print break
    F16 case "f16":s io.print break
    F32 case "f32":s io.print break
    F64 case "f64":s io.print break
    Type case "type":s io.print break
    Tuple case
      "( ":s io.print
        t .Tuple [] .elements for printType ' ' io.print end
      ')' io.print break
    Union case
      "union( ":s io.print
        t .Union [] .elements for printType ' ' io.print end
      ')' io.print break
    Procedure case
      "( ":s io.print
        t .Procedure .inTypes [] .elements for printType ' ' io.print end
        "-> ":s io.print
        t .Procedure .outTypes [] .elements for printType ' ' io.print end
      ')' io.print break
  end
end
proc( Value : val -> ) =>: export: printValue
  val switch
    Int case val .Int io.print break
    Float case val .Float io.print break
    Bool case val .Bool if "true":s else "false":s end io.print break
    Type case val .Type printType break
    Procedure case "procedure@":s io.print val .Procedure iPtr cast! i64 cast.u io.print break
  end
end
proc( TypedValue : val -> ) =>: export: printTypedValue
  val .valType printType
  ": ":s io.print
  val .value printValue
end
proc( TypedValue : val -> bool ) =>: export: asBool
  val .valType .Bool ?? ! and val .valType .None ?? ! if
    "error handling" ..panic
  end
  val .value .Bool ?? ! if
    "error handling" ..panic
  end
  val .value .Bool
end
proc( TypedValue : val -> i32 ) =>: export: asI32
  val .valType .I32 ?? ! and val .valType .None ?? ! if
    "error handling" ..panic
  end
  val .value .Int ?? ! if
    "error handling" ..panic
  end
  val .value .Int i32 cast
end

enum( IF ELSE WHILE DO  PROCEDURE TUPLE_TYPE PROC_TYPE TO_TYPE ) =:: export: BlockType
struct(
  i32 : target
  BlockType : blockType
) =:: export: CodeBlock
proc( CodeBlock : block -> ) =>: export: printBlock
  block .blockType switch
    IF    case "if -> ":s    io.print break
    ELSE  case "else -> ":s  io.print break
    WHILE case "while -> ":s io.print break
    DO    case "do -> ":s    io.print break
    PROCEDURE  case "procedure: ":s    io.print break
    PROC_TYPE  case "proc-type: ":s    io.print break
    TUPLE_TYPE case "tuple-type: ":s   io.print break
    TO_TYPE    case "to-type: ":s      io.print break
  end
  block .target io.println
end
i16 =:: export: IdModifier
namespace: IdModifier
  0:IdModifier =:: export: NONE
  1:IdModifier =:: export: MUTABLE
  2:IdModifier =:: export: BUILTIN
  ( IdModifier IdModifier -> IdModifier ) : alias: export: or i16.or
  ( IdModifier IdModifier -> IdModifier ) : alias: export: and i16.and
  ( IdModifier -> bool ) : alias: export: toBool i16.toBool
end
overload: & IdModifier.and end
overload: | IdModifier.or end
overload: ? IdModifier.toBool end

enum( DECLARE TYPED AUTO TYPED_PROC ) =:: export: InitType
struct( string : name IdModifier : modifiers InitType : initType ) =:: export: InitInfo
union(
  string : Identifier
  string : SetValue
  InitInfo : Initialize
  TypedValue : Constant
  CodeBlock : Block
  CodeBlock : EndBlock
  _ : EOF
) =:: export: Token
proc( Token : token -> ) =>: export: printToken
  "* ":s io.print
  token switch
    Identifier case
      "Identifier: \"":s io.print
      token .Identifier io.print
      "\"":s io.println
      break
    SetValue case
      "SetValue: \"":s io.print
      token .SetValue io.print
      "\"":s io.println
      break
    Initialize case
      token .Initialize .initType switch
        DECLARE case "Declare: \"":s io.print break
        AUTO case "Initialize: \"":s io.print break
        TYPED case "Typed Initialize: \"":s io.print break
        TYPED_PROC case "Proc Initialize: \"":s io.print break
      end
      token .Initialize .name io.print
      "\"":s io.println
      break
    Constant case
      "Constant: ":s io.print token .Constant printTypedValue '\n' io.printC
      break
    Block case
      "Block: ":s io.print token .Block printBlock
      break
    EndBlock case
      "EndBlock: ":s io.print token .EndBlock printBlock
      break
    EOF case
      "EOF":s io.println
      break
  end
end
type : export: BuiltIn
union(
  Token slice : code
  BuiltIn : builtIn
) =:: export: ProcImplementation
struct(
  Type slice : arguments
  ProcImplementation : implementation
) =:: export: Procedure
struct(
  TypedValue : value
  IdModifier : modifiers
) =:: export: Identifier

struct(
  i32 : ifIndex
  i32 : elseIndex
  bool : autoClose
) =:: export: IfBlockInfo
struct(
  i32 : whileIndex
  i32 : doIndex
  ## TODO support break/continue
) =:: export: WhileBlockInfo
enum( NONE PROC TUPLE ) =:: export: CompositeBlockType
struct(
  i32 : blockStart
  i32 : toIndex
  CompositeBlockType : compType
) =:: export: CompositeBlockInfo
struct(
  string : procName
  i32 : blockStart
  IdModifier : idModifiers
) =:: export: ProcedureBlockInfo
union(
  IfBlockInfo : ifBlock
  WhileBlockInfo : whileBlock
  CompositeBlockInfo : compositeBlock
  ProcedureBlockInfo : procedureBlock
) =:: export: BlockInfo
## "interpreter mode" ( set-reset functionality )
##  code
##  type-block
##  initializer
##  enum
##  switch-label?
struct(
  MixedArenaAllocator : memory
  string Identifier hashMap : identifiers
  TypedValue list : stack
  iSize : stackOffset
  ## parser state
  BlockInfo list : openBlocks
  Token list : tokens
  i32 : parseOffset
  bool : running
) =:: export: Program
proc( iSize : argCount Program ptr : program -> bool ) =>: export: checkStack
  argCount program .stack [] .length program [] .stackOffset - u>
end
proc( iSize : argCount Program ptr.mut : program -> iSize ) =>: export: offsetStack
  program [] .stackOffset =:: oldOffset
    argCount program .stack [] .length u<= "enough stack capacity" assert
    program .stack [] .length argCount - program .stackOffset=
  oldOffset
end
proc( iSize : oldOffset Program ptr.mut : program -> ) =>: export: resetStack
  oldOffset program .stack [] .length u<= "enough stack capacity" assert
  oldOffset program .stackOffset=
end
